<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ASL Car Simulator - Babylon Migration (Havok)</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* 页面基本样式 */
        body {
            margin: 0;
            overflow: hidden;
            background: #000000;
            font-family: 'Rajdhani', sans-serif;
            color: #E0FFFF;
            user-select: none;
        }
        /* 全屏画布 */
        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        /* 启动画面 Splash 层 */
        #splash {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, #000000 0%, #0a0a1a 100%);
            z-index: 9999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        #splash h1 {
            font-family: 'Rajdhani', sans-serif;
            font-size: 48px;
            background: linear-gradient(to right, #00FFFF, #FF00FF);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
            margin: 0;
        }
        .splash-subtitle {
            font-family: 'Rajdhani', sans-serif;
            font-size: 18px;
            color: rgba(0, 255, 255, 0.7);
            letter-spacing: 4px;
            margin: 8px 0;
        }
        /* HUD 整体布局 */
        #hud-layer {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column;
            justify-content: space-between;
            padding: 30px;
            box-sizing: border-box;
            z-index: 10;
        }
        .hud-top-left {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        .hud-top-right {
            position: absolute;
            top: 30px;
            right: 30px;
        }
        /* 仪表盘风格 */
        .instrument {
            background: rgba(0, 15, 30, 0.7);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-left: 5px solid #00FFFF;
            backdrop-filter: blur(10px);
            padding: 12px 22px;
            min-width: 120px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.1);
            border-radius: 4px;
            transition: all 0.2s ease;
            clip-path: polygon(0 0, 100% 0, 100% 80%, 90% 100%, 0 100%);
        }
        .instrument:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.4);
        }
        .label {
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            color: #00FFFF;
            font-weight: 700;
            letter-spacing: 2px;
            margin-bottom: 3px;
            display: block;
            text-transform: uppercase;
            text-shadow: 0 0 5px rgba(0, 255, 255, 0.8);
        }
        .value {
            font-family: 'Orbitron', sans-serif;
            font-size: 36px;
            font-weight: 900;
            letter-spacing: -2px;
            line-height: 1;
            color: #FFFFFF;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }
        .unit {
            font-size: 14px;
            color: #888888;
            margin-left: 6px;
            font-weight: 400;
        }
        .spd-color { border-left-color: #00FFFF !important; }
        .rpm-color { border-left-color: #FF00FF !important; }
        .gear-color { border-left-color: #FFD700 !important; }
        .throttle-color { border-left-color: #00FF00 !important; }

        /* HUD 金币计数 */
        #hud-coin {
            background: rgba(35, 18, 0, 0.7);
            border: 1px solid rgba(255, 215, 0, 0.15);
            border-left: 5px solid #FFD700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.06);
            min-width: 140px;
            margin-bottom: 20px;
        }
        #hud-coin .label { color: #FFD700; text-shadow: 0 0 5px rgba(255, 215, 0, 0.6); }
        #coin-count { font-size: 40px; letter-spacing: 2px; color: #FFD700; }

        /* 底部控制提示 */
        #control-hints {
            position: absolute;
            bottom: 30px;
            left: 30px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-left: 5px solid #00FF00;
            backdrop-filter: blur(10px);
            padding: 18px 25px;
            color: #eee;
            font-size: 13px;
            border-radius: 4px;
            max-width: 250px;
            line-height: 1.8;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.1);
        }
        .respawn-hint {
            color: #FFD700;
            font-weight: bold;
        }
        .hint-title {
            color: #00FF00;
            font-family: 'Orbitron', sans-serif;
            font-weight: bold;
            margin-bottom: 10px;
            text-transform: uppercase;
            font-size: 11px;
            border-bottom: 1px solid rgba(0, 255, 0, 0.3);
            padding-bottom: 5px;
            letter-spacing: 2px;
        }
        .copyright-tag {
            position: fixed;
            bottom: 15px;
            right: 15px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.3);
            letter-spacing: 1px;
            z-index: 10;
        }
        /* 加载屏幕 */
        #loading-screen {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            background: #000; color: #00FFFF; z-index: 1000;
            display: none; flex-direction: column;
            align-items: center; justify-content: center;
            opacity: 0; transition: opacity 0.5s;
        }
        #loading-screen p { font-family: 'Orbitron', sans-serif; }
        #loading-progress-bar {
            width: 400px; height: 5px;
            background: #222; margin-top: 10px;
            border-radius: 2px; overflow: hidden;
        }
        #loading-progress-fill {
            height: 100%; width: 0%;
            background: #00FFFF;
            box-shadow: 0 0 10px #00FFFF;
        }
        /* 辅助隐藏类 */
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <!-- Babylon 渲染画布 -->
    <canvas id="renderCanvas"></canvas>

    <!-- 启动画面 -->
    <div id="splash">
        <div id="splash-three-container"></div>
        <h1>HYPER DRIVE</h1>
        <p class="splash-subtitle">MADE BY ZHANYI ZHOU</p>
        <div style="margin-top:16px; color:#FFD700; font-weight:700;">
            Gold Coin collected: <span id="splash-coin-count">0</span>
        </div>
        <button id="start-button">PLAY NOW</button>
    </div>

    <div class="copyright-tag">ZHANYI ZHOU DESIGN © 2025</div>

    <!-- HUD 仪表 -->
    <div id="hud-layer" class="hidden">
        <div class="hud-top-left">
            <div class="instrument spd-color">
                <span class="label">Speed</span>
                <span class="value" id="hud-spd">0</span> <span class="unit">KM/H</span>
            </div>
            <div class="instrument rpm-color">
                <span class="label">RPM</span>
                <span class="value" id="hud-rpm">0</span> <span class="unit">x100</span>
            </div>
            <div class="instrument gear-color">
                <span class="label">Gear</span>
                <span class="value" id="hud-gear">P</span> <span class="unit">MODE</span>
            </div>
            <div class="instrument throttle-color">
                <span class="label">Throttle</span>
                <span class="value" id="hud-throttle">0%</span>
            </div>
            <div class="instrument">
                <span class="label">Altitude</span>
                <span class="value" id="hud-alt">0</span> <span class="unit">M</span>
            </div>
            <div class="instrument">
                <span class="label">Heading</span>
                <span class="value" id="hud-hdg">000</span> <span class="unit">DEG</span>
            </div>
            <div class="instrument">
                <span class="label">Time</span>
                <span class="value" id="hud-time">DAY</span>
            </div>
        </div>

        <div class="hud-top-right">
            <div class="instrument" id="hud-coin">
                <span class="label">GOLD COIN</span>
                <span class="value" id="coin-count">0</span>
            </div>
        </div>

        <div id="control-hints">
            <div class="hint-title">SYSTEM CONTROLS</div>
            <div>[SHIFT] NITRO BOOST (MAX TORQUE)</div>
            <div>[SPACE] HANDBRAKE DRIFT</div>
            <div>[V] TOGGLE CAMERA</div>
            <div class="respawn-hint">[R] RESPAWN CAR (RESETS VELOCITY)</div>
            <div>[WASD] DRIVE</div>
        </div>
    </div>

    <!-- 加载屏幕 -->
    <div id="loading-screen" style="display:none; align-items:center; justify-content:center;">
        <p>LOADING CITY AND ASSETS...</p>
        <div id="loading-progress-bar">
            <div id="loading-progress-fill"></div>
        </div>
        <p id="loading-status" style="margin-top:10px; font-size:14px;">(0%)</p>
    </div>

    <!-- Babylon.js 核心 & Material 库 & GLTF Loader & Havok 物理 -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>

    <script>
    (async function(){
        // ----------------------
        // 基本变量
        // ----------------------
        const canvas = document.getElementById('renderCanvas');
        const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
        let scene = null;
        let followCam = null, cockpitCam = null, activeCam = null;

        // HUD 元素
        const speedEl = document.getElementById('hud-spd');
        const rpmEl = document.getElementById('hud-rpm');
        const gearEl = document.getElementById('hud-gear');
        const throttleEl = document.getElementById('hud-throttle');
        const altitudeEl = document.getElementById('hud-alt');
        const headingEl = document.getElementById('hud-hdg');
        const timeEl = document.getElementById('hud-time');
        const coinCountEl = document.getElementById('coin-count');
        const splashCoinCountEl = document.getElementById('splash-coin-count');
        const loadingFill = document.getElementById('loading-progress-fill');
        const loadingStatus = document.getElementById('loading-status');

        // 玩家输入状态
        const inputState = { keyW:false, keyS:false, keyA:false, keyD:false, keySpace:false, keyShift:false, keyR:false };

        // 物理相关
        let havokInstance = null;
        let havokPlugin = null;
        let chassisMesh = null;      // 隐藏的车体物理壳
        let chassisImpostor = null;
        let wheelVisuals = [];       // 车轮视觉 (圆柱)
        let coinProto = null, coinMeshes = [], coinCount = 0;

        // 常量配置
        const VEHICLE_MASS = 2500;
        const MAX_ENGINE_FORCE = 9000;
        const MAX_STEER = 0.7;
        const COIN_MIN = 50, COIN_MAX = 80;
        const COIN_SPAWN_RADIUS = 800;
        const COIN_HEIGHT = 0.7;

        const WHEEL_NAME_HINTS = [
            "WheelFL", "WheelFR", "WheelBL", "WheelBR",
            "wheel", "tyre", "tire", "Wheel"
        ];
        const BODY_NAME_HINT = "skinned_mesh_carpaint";

        // 初始化场景
        function createScene() {
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.03, 0.03, 0.05, 1);

            // 摄像机
            followCam = new BABYLON.FollowCamera("FollowCam", new BABYLON.Vector3(0,5,-10), scene);
            followCam.radius = 10;
            followCam.heightOffset = 4;
            followCam.rotationOffset = 0;
            followCam.cameraAcceleration = 0.02;
            followCam.maxCameraSpeed = 10;
            followCam.attachControl(canvas, true);
            activeCam = followCam;

            // 灯光
            const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0,1,0), scene);
            hemi.intensity = 0.8;
            const dir = new BABYLON.DirectionalLight("dir", new BABYLON.Vector3(-1,-2,-1), scene);
            dir.position = new BABYLON.Vector3(50,100,50);
            dir.intensity = 1.0;
            dir.shadowEnabled = true;

            // 地面 (作为占位)
            const ground = BABYLON.MeshBuilder.CreateGround("ground", {width:2000, height:2000}, scene);
            ground.position.y = -1;
            const gmat = new BABYLON.StandardMaterial("gmat", scene);
            gmat.diffuseColor = new BABYLON.Color3(0.06, 0.06, 0.06);
            ground.material = gmat;
            ground.receiveShadows = true;

            return scene;
        }

        // Havok 物理初始化
        async function initHavok() {
            if (typeof HavokPhysics === 'undefined') {
                throw new Error("HavokPhysics not available. 检查 Havok 脚本是否加载.");
            }
            havokInstance = await HavokPhysics();
            havokPlugin = new BABYLON.HavokPlugin(true, havokInstance);
            scene.enablePhysics(new BABYLON.Vector3(0, -9.82, 0), havokPlugin);
        }

        // 加载资源：场景、车辆、金币
        async function loadAssetsWithProgress() {
            const assets = [
                { file: "city.glb", name: "city" },
                { file: "car1.glb", name: "car" },
                { file: "gold_coin.glb", name: "coin" }
            ];
            let done = 0;
            const step = () => {
                done++;
                const pct = Math.floor((done/assets.length) * 100);
                loadingFill.style.width = pct + "%";
                loadingStatus.innerText = `(${pct}%) Loading ${done}/${assets.length}`;
            };

            // 加载城市场景 (静态)
            try {
                const res = await BABYLON.SceneLoader.ImportMeshAsync(null, "./", "city.glb", scene);
                res.meshes.forEach(m => {
                    if (m instanceof BABYLON.Mesh) {
                        m.receiveShadows = true;
                        try {
                            m.physicsImpostor = new BABYLON.PhysicsImpostor(
                                m, BABYLON.PhysicsImpostor.MeshImpostor,
                                { mass: 0, friction: 1.0, restitution: 0 }, scene
                            );
                            // 可选：设置睡眠来节省 CPU
                            if (m.physicsImpostor.sleep) m.physicsImpostor.sleep();
                        } catch(e) {
                            console.warn("无法为城市网格创建物理模拟:", m.name, e);
                        }
                    }
                });
            } catch(e) {
                console.error("city.glb 加载失败", e);
            } finally { step(); }

            // 加载车辆模型 (动态)
            try {
                const res = await BABYLON.SceneLoader.ImportMeshAsync(null, "./", "car1.glb", scene);
                // 尝试找到车身 Mesh 作为参考
                let bodyMesh = res.meshes.find(m => m.name && m.name.toLowerCase().includes(BODY_NAME_HINT));
                if (!bodyMesh) bodyMesh = res.meshes.find(m => m.name && /body/i.test(m.name));
                if (!bodyMesh) bodyMesh = res.meshes.find(m => m instanceof BABYLON.Mesh);
                if (!bodyMesh && res.meshes.length > 0) bodyMesh = res.meshes[0];

                if (bodyMesh) {
                    // 根据车身包围盒创建隐藏的物理盒子
                    const bb = bodyMesh.getBoundingInfo().boundingBox;
                    const ext = bb.extendSize;
                    const approx = BABYLON.MeshBuilder.CreateBox("chassisBox", {
                        width: ext.x * 2.2, height: ext.y * 2.4, depth: ext.z * 2.2
                    }, scene);
                    approx.isVisible = false;
                    approx.position = bodyMesh.getAbsolutePosition().clone();
                    // 将车辆可视部件附加到该物理盒子
                    res.meshes.forEach(m => {
                        if (m === approx) return;
                        if (m instanceof BABYLON.Mesh && m !== approx) {
                            m.parent = approx;
                        }
                    });
                    chassisMesh = approx;
                    // 为车体盒子创建物理刚体
                    chassisImpostor = new BABYLON.PhysicsImpostor(
                        chassisMesh, BABYLON.PhysicsImpostor.BoxImpostor,
                        { mass: VEHICLE_MASS, friction: 0.6, restitution: 0 }, scene
                    );
                }
                // 识别车轮 Mesh
                const foundWheels = [];
                res.meshes.forEach(m => {
                    if (!(m instanceof BABYLON.Mesh)) return;
                    const n = (m.name || "").toLowerCase();
                    for (const hint of WHEEL_NAME_HINTS) {
                        if (n.includes(hint.toLowerCase())) {
                            foundWheels.push(m);
                            break;
                        }
                    }
                });
                if (foundWheels.length >= 4) {
                    for (let i = 0; i < 4; i++) {
                        const w = foundWheels[i];
                        if (w) wheelVisuals.push(w);
                    }
                } else {
                    // 未识别到足够的车轮时，创建备用圆柱体车轮
                    for (let i = 0; i < 4; i++) {
                        const cyl = BABYLON.MeshBuilder.CreateCylinder("wheel_vis_" + i, { diameter: 0.8, height: 0.4, tessellation: 24 }, scene);
                        const mat = new BABYLON.StandardMaterial("wheelMat", scene);
                        mat.diffuseColor = new BABYLON.Color3(0.08, 0.08, 0.08);
                        cyl.material = mat;
                        cyl.rotationQuaternion = null;
                        wheelVisuals.push(cyl);
                    }
                }
            } catch(e) {
                console.error("car1.glb 加载失败", e);
            } finally { step(); }

            // 加载金币模型 (克隆用原型)
            try {
                const res = await BABYLON.SceneLoader.ImportMeshAsync(null, "./", "gold_coin.glb", scene);
                if (res.meshes && res.meshes.length > 0) {
                    coinProto = res.meshes[0];
                    coinProto.isVisible = false; // 隐藏原型
                }
            } catch(e) {
                console.error("gold_coin.glb 加载失败", e);
                coinProto = null;
            } finally { step(); }
        }

        // 生成金币 (基于原型克隆，或降级为圆盘)
        function spawnCoinsWhenReady() {
            const num = Math.floor(Math.random() * (COIN_MAX - COIN_MIN + 1)) + COIN_MIN;
            for (let i = 0; i < num; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * COIN_SPAWN_RADIUS;
                const x = Math.cos(angle) * radius + (Math.random() - 0.5) * 20;
                const z = Math.sin(angle) * radius + (Math.random() - 0.5) * 20;
                const y = COIN_HEIGHT + (Math.random() * 0.3 - 0.15);
                if (coinProto) {
                    const clone = coinProto.clone("coin_" + i);
                    clone.isVisible = true;
                    clone.position = new BABYLON.Vector3(x, y, z);
                    clone.rotation = new BABYLON.Vector3(0, Math.random() * Math.PI * 2, 0);
                    scene.addMesh(clone);
                    coinMeshes.push(clone);
                } else {
                    // 简化金色色圆盘
                    const disc = BABYLON.MeshBuilder.CreateCylinder("coin_" + i, { diameter: 0.6, height: 0.06, tessellation: 24 }, scene);
                    const cm = new BABYLON.StandardMaterial("coinMat", scene);
                    cm.diffuseColor = new BABYLON.Color3(1, 0.84, 0);
                    disc.material = cm;
                    disc.position = new BABYLON.Vector3(x, y, z);
                    scene.addMesh(disc);
                    coinMeshes.push(disc);
                }
            }
        }

        // 玩家输入监听
        window.addEventListener('keydown', (e) => {
            const k = e.key.toLowerCase();
            if (k === 'w') inputState.keyW = true;
            if (k === 's') inputState.keyS = true;
            if (k === 'a') inputState.keyA = true;
            if (k === 'd') inputState.keyD = true;
            if (k === ' ') { inputState.keySpace = true; e.preventDefault(); }
            if (k === 'shift') inputState.keyShift = true;
            if (k === 'r') { inputState.keyR = true; respawnCar(); }
            if (k === 'v') toggleCamera();
        });
        window.addEventListener('keyup', (e) => {
            const k = e.key.toLowerCase();
            if (k === 'w') inputState.keyW = false;
            if (k === 's') inputState.keyS = false;
            if (k === 'a') inputState.keyA = false;
            if (k === 'd') inputState.keyD = false;
            if (k === ' ') inputState.keySpace = false;
            if (k === 'shift') inputState.keyShift = false;
            if (k === 'r') inputState.keyR = false;
        });

        // 更新车辆物理 (使用力和扭矩)
        let engineForce = 0, steeringValue = 0;
        function updateVehicle(dt) {
            if (!chassisImpostor || !chassisMesh) return;
            engineForce = 0; steeringValue = 0;
            let vel = new BABYLON.Vector3(0,0,0);
            try { vel = chassisImpostor.getLinearVelocity(); } catch(e) {}

            // 转向输入
            if (inputState.keyA) steeringValue = MAX_STEER;
            else if (inputState.keyD) steeringValue = -MAX_STEER;

            // 油门/刹车
            if (inputState.keyW) {
                engineForce = -MAX_ENGINE_FORCE;
                gearEl.textContent = 'D';
            }
            else if (inputState.keyS) {
                engineForce = MAX_ENGINE_FORCE * 0.5;
                gearEl.textContent = 'R';
            }
            else {
                gearEl.textContent = (vel.length() * 3.6 < 1) ? 'P' : 'N';
            }

            // 氮气加速
            if (inputState.keyShift && engineForce !== 0) {
                engineForce *= 2.5;
                const flame = scene.getMeshByName('flameMesh') || scene.getMeshByName('flame');
                if (flame) flame.isVisible = true;
            } else {
                const flame = scene.getMeshByName('flameMesh') || scene.getMeshByName('flame');
                if (flame) flame.isVisible = false;
            }

            // 计算向前方向（世界空间）
            const forwardLocal = new BABYLON.Vector3(0, 0, 1);
            const forwardWorld = BABYLON.Vector3.TransformCoordinates(forwardLocal, chassisMesh.getWorldMatrix());
            const chassisPos = chassisMesh.getAbsolutePosition();

            // 应用推力
            const forceVec = forwardWorld.subtract(chassisPos).normalize().scale(engineForce * dt);
            try { chassisImpostor.applyImpulse(forceVec, chassisMesh.getAbsolutePosition()); } catch(e) {}

            // 应用转向扭矩 (绕Y轴)
            if (Math.abs(steeringValue) > 1e-4) {
                const torqueVal = steeringValue * Math.min(2500, Math.max(200, vel.length() * 800));
                const torque = new BABYLON.Vector3(0, torqueVal * dt, 0);
                try { chassisImpostor.applyTorque(torque); } catch(e) {}
            }

            // 手刹 (SPACE键) -> 强制阻力
            if (inputState.keySpace) {
                const brakeImpulse = vel.scale(-0.5 * dt * 1000);
                try { chassisImpostor.applyImpulse(brakeImpulse, chassisMesh.getAbsolutePosition()); } catch(e) {}
                gearEl.textContent = 'E';
            }
        }

        // 更新车轮视觉位置
        function updateWheelVisuals(dt) {
            if (!chassisMesh) return;
            const chassisPos = chassisMesh.getAbsolutePosition();
            const rot = chassisMesh.absoluteRotationQuaternion || BABYLON.Quaternion.Identity();
            // 各车轮偏移 (前左, 前右, 后左, 后右)
            const offsets = [
                new BABYLON.Vector3(-1.0, -0.4, 1.4),
                new BABYLON.Vector3( 1.0, -0.4, 1.4),
                new BABYLON.Vector3(-1.0, -0.4, -1.4),
                new BABYLON.Vector3( 1.0, -0.4, -1.4)
            ];
            for (let i = 0; i < wheelVisuals.length; i++) {
                const w = wheelVisuals[i];
                const local = offsets[i].clone();
                local.rotateByQuaternionToRef(rot, local);
                w.position = chassisPos.add(local);
                // 简单旋转动画
                if (w.rotation) {
                    w.rotation.x += (chassisImpostor ? chassisImpostor.getLinearVelocity().length() * 0.1 * dt : 0.02);
                } else if (w.rotationQuaternion) {
                    w.rotate(BABYLON.Axis.X, 0.05 * dt, BABYLON.Space.LOCAL);
                }
            }
        }

        // 更新 HUD 和 日夜循环
        const daySky = new BABYLON.Color3(0.529, 0.808, 0.922);
        const nightSky = new BABYLON.Color3(0.02, 0.02, 0.04);
        const cycleDurationSec = 300;
        function updateHUDAndTime(dt, now) {
            if (!chassisImpostor) return;
            let vel = new BABYLON.Vector3(0,0,0);
            try { vel = chassisImpostor.getLinearVelocity(); } catch(e) {}
            const speedKmh = vel.length() * 3.6;
            speedEl.textContent = Math.floor(speedKmh);
            rpmEl.textContent = Math.min(99, Math.floor(speedKmh * 1.5));
            let throttlePercent = engineForce !== 0 ?
                Math.min(100, Math.abs(engineForce) / (MAX_ENGINE_FORCE * 2.5) * 100) : 0;
            throttleEl.textContent = Math.floor(throttlePercent) + '%';
            coinCountEl.textContent = coinCount;

            // 日夜循环 (简单背景过渡)
            const tSec = now / 1000;
            const cycle = tSec % cycleDurationSec;
            const half = cycleDurationSec / 2;
            let t = 0;
            let label = "DAY";
            if (cycle < half) {
                t = cycle / half;
                label = (t < 0.2) ? "DAY" : (t < 0.8) ? "TWILIGHT" : "NIGHT";
            } else {
                t = (cycle - half) / half;
                label = (t < 0.2) ? "NIGHT" : (t < 0.8) ? "DAWN" : "DAY";
            }
            timeEl.textContent = label;
            const col = BABYLON.Color3.Lerp(daySky, nightSky, t);
            scene.clearColor = new BABYLON.Color4(col.r, col.g, col.b, 1);
        }

        // 检测车辆与金币的碰撞 (简单距离判断)
        function checkCoins() {
            if (!chassisMesh) return;
            const carPos = chassisMesh.getAbsolutePosition();
            for (let i = coinMeshes.length - 1; i >= 0; i--) {
                const c = coinMeshes[i];
                if (!c) continue;
                const d = BABYLON.Vector3.Distance(carPos, c.getAbsolutePosition());
                if (d < 1.0) {
                    try { scene.removeMesh(c, true); } catch(e){}
                    coinMeshes.splice(i, 1);
                    coinCount++;
                    localStorage.setItem('goldCoinCount', coinCount);
                    coinCountEl.textContent = coinCount;
                } else {
                    // 转动金币以示可见
                    c.rotation.y += 0.02;
                }
            }
        }

        // 重置车辆位置
        const initialPosition = new BABYLON.Vector3(90, 0.6, 0);
        function respawnCar() {
            if (!chassisImpostor || !chassisMesh) return;
            try {
                chassisImpostor.setLinearVelocity(BABYLON.Vector3.Zero());
                chassisImpostor.setAngularVelocity(BABYLON.Vector3.Zero());
                chassisMesh.position = initialPosition.clone();
                chassisImpostor.setDeltaPosition(initialPosition);
                gearEl.textContent = 'P';
            } catch(e) { console.warn("车辆重置失败", e); }
        }

        // 切换视角
        function toggleCamera() {
            if (!chassisMesh) return;
            if (!cockpitCam) {
                cockpitCam = new BABYLON.FreeCamera("cockpitCam", chassisMesh.getAbsolutePosition().clone(), scene);
                cockpitCam.parent = chassisMesh;
                cockpitCam.position = new BABYLON.Vector3(0, 0.8, 1.5);
                cockpitCam.rotation = new BABYLON.Vector3(0, Math.PI, 0);
            }
            activeCam = (activeCam === cockpitCam) ? followCam : cockpitCam;
            activeCam.attachControl(canvas, true);
        }

        // 主循环
        let lastFrame = performance.now();
        function startMainLoop() {
            engine.runRenderLoop(() => {
                const now = performance.now();
                const dt = Math.max(1/240, (now - lastFrame) / 1000);
                lastFrame = now;
                // Havok 物理计算由插件自动处理
                updateVehicle(dt);
                updateWheelVisuals(dt);
                checkCoins();
                updateHUDAndTime(dt, now);
                if (scene) scene.render();
            });
        }

        // 点击播放按钮开始
        document.getElementById('start-button').addEventListener('click', async () => {
            // 隐藏启动画面，显示加载界面
            document.getElementById('splash').style.opacity = '0';
            document.getElementById('loading-screen').style.display = 'flex';
            setTimeout(() => { document.getElementById('splash').style.display = 'none'; }, 450);

            // 创建场景并初始化物理
            createScene();
            try {
                await initHavok();
            } catch(e) {
                alert("Havok 初始化失败，请检查网络或 Havok 脚本。Console 查看详情。");
                console.error(e);
                return;
            }

            // 加载模型资源
            await loadAssetsWithProgress();

            // 生成金币
            spawnCoinsWhenReady();

            // 将摄像机锁定到车辆
            if (followCam && chassisMesh) {
                followCam.lockedTarget = chassisMesh;
            }

            // 恢复本地存储的金币数
            const stored = localStorage.getItem('goldCoinCount');
            coinCount = stored ? parseInt(stored, 10) : 0;
            coinCountEl.textContent = coinCount;
            splashCoinCountEl.textContent = coinCount;

            // 显示 HUD
            document.getElementById('loading-screen').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('loading-screen').style.display = 'none';
                document.getElementById('hud-layer').classList.remove('hidden');
            }, 300);

            // 启动渲染循环
            startMainLoop();
        });

        // 窗口调整大小时更新画布
        window.addEventListener('resize', () => engine.resize());

        console.log("Babylon 场景已初始化，点击 PLAY NOW 开始游戏。");
    })();
    </script>
</body>
</html>
