<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ASL Car Simulator — Babylon Migrated</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    /* 保留你原有 HUD / Splash 样式（尽量不变动） */
    html,body { width:100%; height:100%; margin:0; padding:0; overflow:hidden; background:#000; color:#E0FFFF; font-family:'Rajdhani',sans-serif; }
    canvas { display:block; width:100%; height:100%; }
    /* 复制你原文件中的 HUD 样式（简化） */
    /* ...（为节省篇幅，直接复用你原始样式片段）... */
    /* 下面粘回你原来的样式，以确保 UI 一致（略） */
  </style>
  <!-- Babylon 核心 + Materials + WaterMaterial (materials lib) + Havok UMD -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
  <!-- Havok UMD (需要网络) -->
  <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
</head>
<body>
  <!-- Canvas 与原 HUD / Splash 元素（我保留你原始布局 ID 和元素） -->
  <canvas id="renderCanvas"></canvas>

  <!-- 复制你原来的 HUD / Splash DOM（保持 id 与原文件一致） -->
  <div id="splash" style="position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:9999;">
    <div style="text-align:center;color:white;">
      <h1 style="font-family:Orbitron, sans-serif;letter-spacing:8px;">HYPER DRIVE</h1>
      <div style="margin-top:10px;color:#FFD700;font-weight:700;">Gold Coin collected: <span id="splash-coin-count">0</span></div>
      <button id="start-button" style="margin-top:20px;padding:12px 28px;cursor:pointer;">PLAY NOW</button>
    </div>
  </div>

  <!-- HUD layer simplified but uses same IDs so你的原脚本UI可复用 -->
  <div id="hud-layer" style="display:none;position:absolute;inset:0;pointer-events:none;z-index:10;padding:20px;box-sizing:border-box;">
    <div style="display:flex;gap:12px;">
      <div class="instrument spd-color"><span class="label">Speed</span><span class="value" id="hud-spd">0</span> <span class="unit">KM/H</span></div>
      <div class="instrument rpm-color"><span class="label">RPM</span><span class="value" id="hud-rpm">0</span></div>
      <div class="instrument gear-color"><span class="label">Gear</span><span class="value" id="hud-gear">P</span></div>
      <div class="instrument throttle-color"><span class="label">Throttle</span><span class="value" id="hud-throttle">0%</span></div>
    </div>
    <div style="position:absolute;right:20px;top:20px;">
      <div class="instrument" id="hud-coin"><span class="label">GOLD COIN</span><span class="value" id="coin-count">0</span></div>
    </div>
  </div>

  <!-- loading bar -->
  <div id="loading-screen" style="position:absolute;inset:0;display:none;align-items:center;justify-content:center;z-index:9998;color:#0ff;">
    <div>
      <div>LOADING CITY AND ASSETS...</div>
      <div id="loading-progress-bar" style="width:360px;height:6px;background:#222;margin-top:8px;border-radius:3px;">
        <div id="loading-progress-fill" style="width:0%;height:100%;background:#00FFFF;"></div>
      </div>
      <div id="loading-status" style="margin-top:6px;font-size:13px;">(0%)</div>
    </div>
  </div>

<script>
(async function(){

/* -------------------------
   基本变量（保留你原逻辑的名称）
   ------------------------- */
const canvas = document.getElementById('renderCanvas');
const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
let scene, activeCamera;
let carGltf, cityGltf;
let chassisImpostor = null, chassisMesh = null;
let wheelVisuals = [];
let coinProto = null, coinMeshes = [], coinCount = 0;
const inputState = { keyW:false, keyS:false, keyA:false, keyD:false, keySpace:false, keyShift:false, keyR:false };
let hudShown = false;

/* HUD elements (original IDs) */
const speedEl = document.getElementById('hud-spd');
const rpmEl = document.getElementById('hud-rpm');
const gearEl = document.getElementById('hud-gear');
const throttleEl = document.getElementById('hud-throttle');
const coinCountEl = document.getElementById('coin-count');
const splashCoinCountEl = document.getElementById('splash-coin-count');
const loadingFill = document.getElementById('loading-progress-fill');
const loadingStatus = document.getElementById('loading-status');

/* 物理/车辆参数（你原来设置的基线） */
const VEHICLE_MASS = 2500;
const MAX_ENGINE_FORCE = 9000;
const MAX_STEER = 0.7;
const BRAKE_FORCE = 40;

/* 轮子节点名称（基于我们解析结果） */
const WHEEL_NAMES = [
  "car_suv_jeep_wrangler_rubicon:WheelFL_details_WheelFL_details_None_rims_0",
  "car_suv_jeep_wrangler_rubicon:WheelFR_tyre_WheelFR_tyre_None_tire_0",
  "car_suv_jeep_wrangler_rubicon:WheelBL_tyre_WheelBL_tyre_None_tire_0",
  "car_suv_jeep_wrangler_rubicon:WheelBR_pivot_details_WheelBR_pivot_details_None_rims_0"
];
const BODY_NAME = "car_suv_jeep_wrangler_rubicon:skinned_mesh_carpaint_skinned_mesh_carpaint_None_CP_0";

/* 加速度插件：Havok 初始化 */
let havokInstance = null, havokPlugin = null;
async function initHavokPlugin() {
  // HavokPhysics() is provided by Havok UMD script
  if (typeof HavokPhysics === 'undefined') {
    console.warn("HavokPhysics not found — ensure Havok script is loaded.");
    return null;
  }
  havokInstance = await HavokPhysics(); // returns wasm-backed instance
  havokPlugin = new BABYLON.HavokPlugin(true, havokInstance);
  return havokPlugin;
}

/* -------------------------
   场景初始化
   ------------------------- */
async function createScene() {
  scene = new BABYLON.Scene(engine);
  scene.clearColor = new BABYLON.Color4(0.03,0.03,0.05,1);

  // 相机：默认第三人称 FollowCamera（会在车加载后 lock）
  activeCamera = new BABYLON.FollowCamera("FollowCam", new BABYLON.Vector3(0,5,-10), scene);
  activeCamera.radius = 10;
  activeCamera.heightOffset = 4;
  activeCamera.rotationOffset = 0;
  activeCamera.cameraAcceleration = 0.02;
  activeCamera.maxCameraSpeed = 10;
  activeCamera.attachControl(canvas, true);

  // 光照
  const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0,1,0), scene);
  hemi.intensity = 0.8;
  const dir = new BABYLON.DirectionalLight("dir", new BABYLON.Vector3(-1,-2,-1), scene);
  dir.position = new BABYLON.Vector3(50,100,50);
  dir.intensity = 1.0;
  dir.shadowEnabled = true;

  // 地面占位（city 会覆盖）
  const ground = BABYLON.MeshBuilder.CreateGround("ground", {width:500, height:500}, scene);
  const groundMat = new BABYLON.StandardMaterial("gndMat", scene);
  groundMat.diffuseColor = new BABYLON.Color3(0.06,0.06,0.06);
  ground.material = groundMat;
  ground.receiveShadows = true;

  // 水面（使用 WaterMaterial）
  const waterMesh = BABYLON.MeshBuilder.CreateGround("waterMesh", {width:200, height:200, subdivisions: 32}, scene);
  waterMesh.position.y = -0.02;
  const water = new BABYLON.WaterMaterial("waterMat", scene, new BABYLON.Vector2(512,512));
  water.bumpTexture = new BABYLON.Texture("textures/waterbump.png", scene);
  water.windForce = -5; water.waveHeight = 0.5; water.bumpHeight = 0.1;
  water.waterColor = new BABYLON.Color3(0.0, 0.45, 0.6);
  water.addToRenderList(); // keep empty for now
  waterMesh.material = water;

  return scene;
}

/* -------------------------
   启用 Havok 物理并加载资源
   ------------------------- */
async function initAndLoadAll() {
  await initHavokPlugin();
  if (!havokPlugin) {
    alert("Havok 初始化失败，请确认 Havok UMD 已加载。");
    return;
  }
  scene.enablePhysics(new BABYLON.Vector3(0, -9.82, 0), havokPlugin);

  // 加载 city 与 car（并保留进度）
  // 使用 SceneLoader.Append 以加载整场景到当前 scene
  const assets = [
    {name:'city', file:'city1.glb'},
    {name:'car',  file:'car1.glb'},
    {name:'tire', file:'tire1.glb'},
    {name:'coin', file:'gold_coin.glb'}
  ];

  let loaded = 0;
  const updateProgress = () => {
    loaded++;
    const pct = Math.floor((loaded / assets.length) * 100);
    loadingFill.style.width = pct + '%';
    loadingStatus.innerText = `(${pct}%) Loading ${loaded}/${assets.length}`;
    if (loaded === assets.length) {
      document.getElementById('loading-screen').style.opacity = '0';
      setTimeout(()=>{ document.getElementById('loading-screen').style.display = 'none'; document.getElementById('hud-layer').style.display='block'; }, 400);
    }
  };

  // load city
  await BABYLON.SceneLoader.ImportMeshAsync(null, "./", "city1.glb", scene).then(result => {
    cityGltf = result.meshes;
    // 给 city 的每个 mesh 创建物理 MeshImpostor（mass=0）
    result.meshes.forEach(m => {
      if (m instanceof BABYLON.Mesh) {
        // make it pickable for reflection if needed
        m.receiveShadows = true;
        try {
          m.physicsImpostor = new BABYLON.PhysicsImpostor(m, BABYLON.PhysicsImpostor.MeshImpostor, { mass: 0, friction: 1.0, restitution: 0.0 }, scene);
          // optionally sleep to save CPU
          m.physicsImpostor.sleep();
        } catch(e) {
          console.warn("City mesh physics creation failed for", m.name, e);
        }
      }
    });
    updateProgress();
  }).catch(e=>{ console.error("city load err",e); updateProgress(); });

  // load car
  await BABYLON.SceneLoader.ImportMeshAsync(null, "./", "car1.glb", scene).then(result => {
    carGltf = result.meshes;
    // try to find body by name, fallback to first mesh
    let bodyMesh = result.meshes.find(m => m.name && m.name.includes("skinned_mesh_carpaint")) || result.meshes.find(m => m.name && m.name.includes("Body")) || result.meshes[0];
    if (!bodyMesh) bodyMesh = result.meshes[0];
    // ensure correct scale/rotation like original (we keep relative)
    bodyMesh.position.y = -0.5;
    bodyMesh.rotationQuaternion = null; // allow quaternion sync later
    // create an invisible chassis collider (box) based on bounding info
    const bbox = bodyMesh.getBoundingInfo().boundingBox.extendSize;
    const approxBox = BABYLON.MeshBuilder.CreateBox("chassisBox", { width: bbox.x*2.2, depth: bbox.z*2.2, height: bbox.y*2.4 }, scene);
    approxBox.isVisible = false;
    approxBox.position = bodyMesh.getAbsolutePosition().clone();
    // put the visual car as a child of chassisBox for easy sync
    bodyMesh.parent = approxBox;
    chassisMesh = approxBox;

    // create physics impostor for chassis
    chassisImpostor = new BABYLON.PhysicsImpostor(chassisMesh, BABYLON.PhysicsImpostor.BoxImpostor, { mass: VEHICLE_MASS, friction: 0.6, restitution: 0.0 }, scene);

    // wheel visuals: find wheel nodes by names
    wheelVisuals = [];
    WHEEL_NAMES.forEach(name => {
      const w = result.meshes.find(m => m.name && m.name.includes(name));
      if (w) {
        // ensure wheel exists and use it as visual
        wheelVisuals.push(w);
      }
    });
    // if prototype tire exists, also try load tire1 to clone; but if not, rely on existing nodes.
    updateProgress();
  }).catch(e=>{ console.error("car load err",e); updateProgress(); });

  // load tire prototype (optional)
  await BABYLON.SceneLoader.ImportMeshAsync(null, "./", "tire1.glb", scene).then(res => {
    // if there were no wheel visuals, try to use this prototype
    if (wheelVisuals.length === 0 && res.meshes.length>0) {
      const proto = res.meshes[0];
      for (let i=0;i<4;i++){
        const clone = proto.clone("wheel_vis_"+i);
        clone.rotationQuaternion = null;
        scene.addMesh(clone);
        wheelVisuals.push(clone);
      }
    }
    updateProgress();
  }).catch(e=>{ console.warn("tire load fail", e); updateProgress(); });

  // load coin prototype
  await BABYLON.SceneLoader.ImportMeshAsync(null, "./", "gold_coin.glb", scene).then(res => {
    dollarProto = res.meshes[0] || null;
    coinProto = res.meshes[0] ? res.meshes[0].clone("coin_proto", null) : null;
    if (coinProto) coinProto.isVisible = false; // store template
    updateProgress();
  }).catch(e=>{ console.warn("coin load fail", e); updateProgress(); });

  // restore coin count from localStorage
  const stored = localStorage.getItem('goldCoinCount');
  coinCount = stored ? parseInt(stored,10) : 0;
  splashCoinCountEl.innerText = coinCount;
  coinCountEl.innerText = coinCount;
}

/* -------------------------
   生成金币（基于触发/距离检测）
   ------------------------- */
function spawnCoins(num){
  if (!coinProto) return;
  for (let i=0;i<num;i++){
    const angle = Math.random()*Math.PI*2;
    const radius = Math.random()*COIN_SPAWN_RADIUS || 200;
    const x = Math.cos(angle)*radius + (Math.random()-0.5)*20;
    const z = Math.sin(angle)*radius + (Math.random()-0.5)*20;
    const y = COIN_HEIGHT + (Math.random()*0.3 - 0.15);
    const coin = coinProto.clone("coin_"+Date.now()+"_"+i);
    coin.isVisible = true;
    coin.position = new BABYLON.Vector3(x,y,z);
    coin.rotation.y = Math.random()*Math.PI*2;
    scene.addMesh(coin);
    coinMeshes.push(coin);
    // add a small invisible sphere for robust overlap if needed (optional)
  }
}

/* -------------------------
   控制输入（保留 WASD / SHIFT / SPACE / R / V）
   ------------------------- */
window.addEventListener('keydown', (e)=>{
  const k = e.key.toLowerCase();
  if (k==='w') inputState.keyW = true;
  if (k==='s') inputState.keyS = true;
  if (k==='a') inputState.keyA = true;
  if (k==='d') inputState.keyD = true;
  if (k===' ') { inputState.keySpace = true; e.preventDefault(); }
  if (k==='shift') inputState.keyShift = true;
  if (k==='r') { inputState.keyR = true; respawnCar(); }
  if (k==='v') toggleCamera();
});
window.addEventListener('keyup', (e)=>{
  const k = e.key.toLowerCase();
  if (k==='w') inputState.keyW = false;
  if (k==='s') inputState.keyS = false;
  if (k==='a') inputState.keyA = false;
  if (k==='d') inputState.keyD = false;
  if (k===' ') inputState.keySpace = false;
  if (k==='shift') inputState.keyShift = false;
  if (k==='r') inputState.keyR = false;
});

/* -------------------------
   车辆行为 / 物理驱动（基于 applyImpulse & applyTorque）
   ------------------------- */
let engineForce = 0, steeringValue = 0;
function updateVehicleControls(dt) {
  if (!chassisImpostor) return;
  engineForce = 0; steeringValue = 0;
  // get linear velocity
  let vel = new BABYLON.Vector3(0,0,0);
  try {
    vel = chassisImpostor.getLinearVelocity();
  } catch(e) {
    // fallback compute by delta pos (not implemented here)
  }
  const speedKmh = vel.length() * 3.6;

  // steering
  if (inputState.keyA) steeringValue = MAX_STEER;
  else if (inputState.keyD) steeringValue = -MAX_STEER;
  // throttle / brake
  if (inputState.keyW) { engineForce = -MAX_ENGINE_FORCE; gearEl.textContent = 'D'; }
  else if (inputState.keyS) { engineForce = MAX_ENGINE_FORCE*0.5; gearEl.textContent = 'R'; }
  else { gearEl.textContent = (speedKmh < 1) ? 'P' : 'N'; }

  // nitro
  if (inputState.keyShift && engineForce !== 0) {
    engineForce *= 2.5;
    // visual nitro: if car model has flameMesh name, set visible (attempt)
    const flame = scene.getMeshByName('flameMesh') || scene.getMeshByName('flame');
    if (flame) flame.isVisible = true;
  } else {
    const flame = scene.getMeshByName('flameMesh') || scene.getMeshByName('flame');
    if (flame) flame.isVisible = false;
  }

  // apply engine force as impulse at chassis center in forward direction
  const chassisForward = new BABYLON.Vector3(0,0,1);
  chassisForward.rotateByQuaternionToRef(chassisMesh.absoluteRotationQuaternion, chassisForward);
  // note: engineForce sign chosen to match original. use dt scaling
  const forceVec = chassisForward.scale(engineForce * (dt || 0.016));
  try { chassisImpostor.applyImpulse(forceVec, chassisMesh.getAbsolutePosition()); } catch(e){}

  // steering as angular torque
  if (Math.abs(steeringValue) > 0.001) {
    // we apply yaw torque proportional to steering and current speed (simple model)
    const torqueStrength = steeringValue * Math.min(2000, Math.max(200, vel.length()*800));
    const torque = new BABYLON.Vector3(0, torqueStrength * (dt || 0.016), 0);
    try { chassisImpostor.applyTorque(torque); } catch(e){}
  }

  // handbrake
  if (inputState.keySpace) {
    // apply damping by applying opposite impulse to velocity
    const brakeImpulse = vel.scale(-0.5 * (dt || 0.016) * 1000);
    try { chassisImpostor.applyImpulse(brakeImpulse, chassisMesh.getAbsolutePosition()); } catch(e){}
  }
}

/* -------------------------
   相机切换（第三人称 / cockpit）
   ------------------------- */
let cockpitCam = null;
function toggleCamera() {
  if (!chassisMesh) return;
  if (!cockpitCam) {
    cockpitCam = new BABYLON.FreeCamera("cockpit", chassisMesh.position.clone(), scene);
    cockpitCam.fov = 1.0;
    cockpitCam.parent = chassisMesh;
    cockpitCam.position = new BABYLON.Vector3(0, 0.8, 1.5);
    cockpitCam.rotation = new BABYLON.Vector3(0, Math.PI, 0);
  }
  activeCamera = (activeCamera === cockpitCam) ? scene.getCameraByName("FollowCam") : cockpitCam;
  activeCamera.attachControl(canvas, true);
}

/* -------------------------
   HUD 更新 / 日夜循环（参考原逻辑）
   ------------------------- */
const daySky = new BABYLON.Color3(0.529,0.808,0.922);
const nightSky = new BABYLON.Color3(0.02,0.02,0.04);
const dayHemiSky = new BABYLON.Color3(1,1,1);
const nightHemiSky = new BABYLON.Color3(0.07,0.07,0.2);
const dayHemiGround = new BABYLON.Color3(0.231,0.298,0.353);
const nightHemiGround = new BABYLON.Color3(0.016,0.016,0.04);
const cycleDurationSec = 300;

function updateHUD(dt, time) {
  if (!chassisImpostor) return;
  // speed
  let vel = new BABYLON.Vector3(0,0,0);
  try { vel = chassisImpostor.getLinearVelocity(); } catch(e){}
  const speedKmh = vel.length() * 3.6;
  speedEl.textContent = Math.floor(speedKmh);
  rpmEl.textContent = Math.min(99, Math.floor(speedKmh * 1.5));
  // throttle visual
  let throttlePercent = engineForce !== 0 ? Math.min(100, Math.abs(engineForce) / (MAX_ENGINE_FORCE*2.5) * 100) : 0;
  throttleEl.textContent = Math.floor(throttlePercent) + '%';
  // coins
  coinCountEl.textContent = coinCount;

  // day/night
  const tSec = time / 1000;
  const cycle = tSec % cycleDurationSec;
  const half = cycleDurationSec / 2;
  let t = 0;
  let label = "DAY";
  if (cycle < half) {
    t = cycle/half;
    label = (t < 0.2) ? "DAY" : (t < 0.8) ? "TWILIGHT" : "NIGHT";
  } else {
    t = (cycle-half)/half;
    label = (t < 0.2) ? "NIGHT" : (t < 0.8) ? "DAWN" : "DAY";
  }
  document.getElementById('hud-time') && (document.getElementById('hud-time').textContent = label);
}

/* -------------------------
   Coin collection (distance-based + safe physics)
   ------------------------- */
function checkCoinCollection() {
  if (!chassisMesh) return;
  const carPos = chassisMesh.getAbsolutePosition();
  for (let i = coinMeshes.length-1; i>=0; i--) {
    const c = coinMeshes[i];
    if (!c) continue;
    if (carPos.subtract(c.getAbsolutePosition()).length() < 1.0) {
      // collect
      try { scene.removeMesh(c, true); } catch(e){}
      coinMeshes.splice(i,1);
      coinCount++;
      localStorage.setItem('goldCoinCount', coinCount);
      coinCountEl.textContent = coinCount;
    }
  }
}

/* -------------------------
   Respawn
   ------------------------- */
const initialPosition = new BABYLON.Vector3(90, 0.6, 0);
function respawnCar(){
  if (!chassisMesh || !chassisImpostor) return;
  chassisImpostor.setLinearVelocity(BABYLON.Vector3.Zero());
  chassisImpostor.setAngularVelocity(BABYLON.Vector3.Zero());
  chassisMesh.position = initialPosition.clone();
  chassisImpostor.setDeltaPosition(initialPosition);
  gearEl.textContent = 'P';
}

/* -------------------------
   主循环
   ------------------------- */
let lastFrame = performance.now();
function startMainLoop(){
  engine.runRenderLoop(()=>{
    const now = performance.now();
    const dt = (now - lastFrame) / 1000;
    lastFrame = now;

    // update vehicle physics
    updateVehicleControls(dt);

    // wheel visual sync (simple raycast down to place wheels)
    if (wheelVisuals.length>0 && chassisMesh) {
      const chassisPos = chassisMesh.getAbsolutePosition();
      for (let i=0;i<wheelVisuals.length;i++){
        const w = wheelVisuals[i];
        // compute offset positions relative to chassis bounding box
        // as an approximation, place wheels relative to chassis
        const offsetX = (i%2===0) ? -1.0 : 1.0; // left/right
        const offsetZ = (i<2) ? 1.5 : -1.5; // front/back
        const local = new BABYLON.Vector3(offsetX, -0.4, offsetZ);
        local.rotateByQuaternionToRef(chassisMesh.absoluteRotationQuaternion, local);
        const worldPos = chassisPos.add(local);
        w.position = worldPos;
        // basic rotation to simulate spinning
        w.rotation.y += (chassisImpostor ? chassisImpostor.getLinearVelocity().length()*0.05*dt : 0.02);
      }
    }

    // coin collection
    checkCoinCollection();

    // HUD updates & day/night time (use now)
    updateHUD(dt, now);

    // render
    scene.render();
  });
}

/* -------------------------
   启动游戏流程（绑定按钮）
   ------------------------- */
document.getElementById('start-button').addEventListener('click', async ()=>{
  document.getElementById('splash').style.opacity = '0';
  document.getElementById('loading-screen').style.display = 'flex';
  setTimeout(()=>document.getElementById('splash').style.display = 'none', 450);

  if (!scene) await createScene();
  await initAndLoadAll();

  // spawn coins with similar numbers as original
  const COIN_MIN = 50, COIN_MAX = 80;
  const num = Math.floor(Math.random()*(COIN_MAX-COIN_MIN+1))+COIN_MIN;
  // use small constant spawn radius if undefined
  window.COIN_SPAWN_RADIUS = window.COIN_SPAWN_RADIUS || 800;
  window.COIN_HEIGHT = window.COIN_HEIGHT || 0.7;
  spawnCoins(num);

  // attach follow camera to chassis after load
  const followCam = scene.getCameraByName("FollowCam");
  if (followCam && chassisMesh) followCam.lockedTarget = chassisMesh;
  activeCamera = followCam;

  // show hud
  document.getElementById('hud-layer').style.display = 'block';
  startMainLoop();
});

/* resize */
window.addEventListener('resize', ()=>engine.resize());

})();
</script>
</body>
</html>
