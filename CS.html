<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASL Car Simulator - FIXED</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; user-select: none; }
        
        /* ä»ªè¡¨ç›˜å¸ƒå±€ */
        #hud-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
            padding: 25px; box-sizing: border-box; z-index: 10;
        }

        .hud-top-left { display: flex; gap: 20px; flex-wrap: wrap; }
        
        .instrument {
            background: rgba(10, 20, 30, 0.75);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-left: 4px solid #00aaff;
            backdrop-filter: blur(8px);
            padding: 10px 18px;
            color: #eee;
            min-width: 100px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            border-radius: 4px;
        }
        
        .label {
            font-size: 10px; color: #88ccff; font-weight: 600; letter-spacing: 1px;
            margin-bottom: 4px; display:block; text-transform: uppercase;
        }
        
        .value {
            font-size: 26px; font-weight: 700; font-family: 'Consolas', monospace; letter-spacing: -1px;
        }
        
        .unit {
            font-size: 12px; color: #888; margin-left: 4px; font-weight: 400;
        }

        /* æ§åˆ¶æç¤º */
        #control-hints {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(10, 20, 30, 0.75);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-left: 4px solid #00ff00;
            backdrop-filter: blur(8px);
            padding: 15px 20px;
            color: #eee;
            font-size: 12px;
            border-radius: 4px;
            max-width: 200px;
            line-height: 1.6;
        }

        .hint-title {
            color: #00ff00;
            font-weight: bold;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        /* å¯åŠ¨ç”»é¢ (Splash Screen) */
        #splash {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #0093E9 0%, #80D0C7 100%);
            z-index: 999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white;
            text-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }
        
        #splash-three-container {
            width: 300px;
            height: 150px;
            margin-bottom: 20px;
            position: relative;
        }

        h1 {
            font-size: 32px;
            margin: 0;
            font-weight: 400;
            letter-spacing: 5px;
            text-transform: uppercase;
            color: #fff;
            text-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }

        /* æ–°å¢ç‰ˆæƒä¿¡æ¯æ ·å¼ */
        #copyright-info {
            position: absolute;
            bottom: 10px;
            opacity: 0.7;
            font-size: 12px;
        }

        /* å¯åŠ¨ç”»é¢ä¸­åŸæœ‰çš„ä¸ç›¸å…³æ ·å¼å·²ç§»é™¤ï¼Œä¿ç•™æ ¸å¿ƒç»“æ„ */
        #plane-chooser-title {
            font-size: 20px;
            margin-bottom: 20px;
            font-weight: 600;
            color: #f0f0f0;
            letter-spacing: 3px;
        }

        #plane-info-display {
            text-align: center;
            margin-top: 15px;
            padding: 15px 30px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            min-width: 450px;
        }

        .plane-title {
            font-size: 18px;
            font-weight: 700;
            color: #fff;
            margin-bottom: 10px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px 20px;
            font-size: 13px;
            color: #c0e0f0;
        }

        .stat-value {
            font-family: 'Consolas', monospace;
            font-weight: bold;
            color: #80D0C7;
            margin-left: 5px;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: auto auto;
            gap: 10px 20px;
            margin-top: 20px;
            text-align: left;
            background: rgba(0,0,0,0.3);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.2);
            font-size: 14px;
        }

        .key-box {
            font-family: 'Consolas', monospace;
            color: #80D0C7;
            font-weight: bold;
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div id="splash">
        <div id="splash-three-container"></div>
        <h1>ASL CAR SIMULATOR</h1>
        <p style="opacity:0.8; margin-top:15px;">Press Start to Play</p>
        <button id="start-button" onclick="startGame()">START DRIVING</button>
        <p id="copyright-info">Â© 2025 Zhanyi Zhou & Gemini AI</p>
    </div>

    <div id="hud-layer" style="display:none;">
        <div class="hud-top-left">
            <div class="instrument">
                <span class="label">Speed</span>
                <span class="value" id="hud-spd">0</span> <span class="unit">KM/H</span>
            </div>
            <div class="instrument">
                <span class="label">Altitude</span>
                <span class="value" id="hud-alt">0</span> <span class="unit">M</span>
            </div>
            <div class="instrument">
                <span class="label">Heading</span>
                <span class="value" id="hud-hdg">000</span> <span class="unit">DEG</span>
            </div>
            <div class="instrument" style="border-left-color: #ffcc00;">
                <span class="label" style="color:#ffcc00">RPM</span>
                <span class="value" id="hud-rpm">0</span> <span class="unit">x100</span>
            </div>
            <div class="instrument" style="border-left-color: #ff9900;">
                <span class="label" style="color:#ff9900">Gear</span>
                <span class="value" id="hud-gear">P</span> <span class="unit">MODE</span>
            </div>
            <div class="instrument" style="border-left-color: #ff6699;">
                <span class="label" style="color:#ff6699">Steer</span>
                <span class="value" id="hud-steer">0Â°</span> <span class="unit">ANGLE</span>
            </div>
        </div>

        <div class="hud-bottom">
            <div id="control-hints">
                <div class="hint-title">ğŸ’¡ Tips</div>
                <div>Press Shift for Boost</div>
                <div>SPACE for handbrake drift</div>
                <div>V to switch camera</div>
                <div>**R to Respawn**</div>
            </div>
            <div class="hud-bottom-right">
                <div class="instrument" style="border-left-color: #00ff00;">
                    <span class="label" style="color:#00ff00">Throttle</span>
                    <span class="value" id="hud-throttle">0%</span>
                </div>
            </div>
        </div>
    </div>

    <div id="loading-screen" style="display:none; flex-direction:column; align-items:center; justify-content:center; position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8); color:#fff; z-index:1000;">
        <p>Loading City and Assets...</p>
        <div id="loading-progress-bar" style="width:300px; height:10px; background:#333; margin-top:10px;">
            <div id="loading-progress-fill" style="height:100%; width:0%; background:#00aaff;"></div>
        </div>
        <p id="loading-status" style="margin-top:10px; font-size:14px;">(0%)</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>

    <script>
    // =============================================================================
    // ** ä¸»æ¸¸æˆ 3D åœºæ™¯å˜é‡ **
    // =============================================================================
    let scene, renderer;
    let cameraChase, cameraCockpit, activeCamera;
    let world, vehicle, chassisBody;
    let wheelMeshes = [];
    let lastTime = undefined;

    // ** ç¯å¢ƒå…‰/æ—¥å¤œåˆ‡æ¢å˜é‡ (å·²ç§»é™¤æ—¥å¤œåˆ‡æ¢é€»è¾‘ï¼Œä»…ä¿ç•™ç™½å¤©è®¾ç½®) **
    const daySkyColor = new THREE.Color(0x87CEEB);
    const dayHemiSky = new THREE.Color(0xffffff);
    const dayHemiGround = new THREE.Color(0x3b4c5a);
    let hemiLight, dirLight;


    // ** å…³é”®çš„çŠ¶æ€å˜é‡ **
    let staticBodies = [];
    let carMesh = null;
    let tireMeshPrototype = null;
    let flameMesh = null;
    let gltfLoader = null;
    let dracoLoader = null;

    const inputState = {
      keyW: false,
      keyS: false,
      keyA: false,
      keyD: false,
      keySpace: false,
      keyShift: false,
      keyR: false // æ–°å¢ï¼šRé”®é‡ç”ŸçŠ¶æ€
    };

    // å¼•æ“å’Œè½¬å‘å‚æ•°
    const maxEngineForce = 12000;
    const maxSteerVal = 1.6; // å¢å¤§è½¬å¼¯å¹…åº¦
    const steeringSmoothFactor = 0.15; // æé«˜è½¬å‘å“åº”é€Ÿåº¦

    // ä»ªè¡¨ç›˜å…ƒç´ 
    const speedEl = document.getElementById('hud-spd');
    const altitudeEl = document.getElementById('hud-alt');
    const headingEl = document.getElementById('hud-hdg');
    const rpmEl = document.getElementById('hud-rpm');
    const gearEl = document.getElementById('hud-gear');
    const steerEl = document.getElementById('hud-steer');
    const throttleEl = document.getElementById('hud-throttle');

    let engineForce = 0;
    let steeringValue = 0;
    let targetSteeringValue = 0; // æ–°å¢ï¼šå¹³æ»‘è½¬å‘çš„ç›®æ ‡å€¼

    // =============================================================================
    // ** THREE.js/GLTF Loader åˆå§‹åŒ– **
    // =============================================================================
    function initLoaders() {
        dracoLoader = new THREE.DRACOLoader();
        dracoLoader.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/draco/');

        // ä½¿ç”¨ LoadingManager è¿›è¡Œç»Ÿä¸€åŠ è½½ç®¡ç†
        const loadingManager = new THREE.LoadingManager();
        const progressFill = document.getElementById('loading-progress-fill');
        const loadingStatus = document.getElementById('loading-status');
        loadingManager.onProgress = function(itemUrl, itemsLoaded, itemsTotal) {
            const percent = Math.floor((itemsLoaded / itemsTotal) * 100);
            progressFill.style.width = percent + '%';
            loadingStatus.innerText = `(${percent}%) Loading Assets...`;
        };
        loadingManager.onLoad = function() {
            // æ‰€æœ‰èµ„æºåŠ è½½å®Œæˆï¼Œå¯åŠ¨æ¸¸æˆ
            cancelAnimationFrame(splashAnimationId);
            document.getElementById('loading-screen').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('loading-screen').style.display = 'none';
                document.getElementById('hud-layer').style.display = 'flex';
            }, 500);
            initVehicle();
            requestAnimationFrame(animate);
        };

        gltfLoader = new THREE.GLTFLoader(loadingManager);
        gltfLoader.setDRACOLoader(dracoLoader);
    }

    // =============================================================================
    // ** å¯åŠ¨ç”»é¢ 3D åœºæ™¯é€»è¾‘ **
    // =============================================================================
    let splashScene, splashCamera, splashRenderer, splashAnimationId, splashCarModel;
    function initSplashThree() {
        const container = document.getElementById('splash-three-container');
        const width = container.clientWidth;
        const height = container.clientHeight;

        splashScene = new THREE.Scene();
        splashCamera = new THREE.PerspectiveCamera(60, width/height, 0.1, 1000);
        splashRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        splashRenderer.setSize(width, height);
        splashRenderer.setClearColor(0x000000, 0);
        container.appendChild(splashRenderer.domElement);

        // æ·»åŠ æ—‹è½¬çš„æ±½è½¦æ¨¡å‹
        const ambient = new THREE.AmbientLight(0xffffff, 0.8);
        splashScene.add(ambient);
        const dir = new THREE.DirectionalLight(0xffffff, 0.6);
        dir.position.set(5,10,7.5);
        splashScene.add(dir);

        splashCamera.position.set(0, 1, 3);
        splashCamera.lookAt(0, 0.5, 0);

        // æ—‹è½¬åŠ¨ç”»
        function animateSplash() {
            splashAnimationId = requestAnimationFrame(animateSplash);
            if (splashCarModel) {
                splashCarModel.rotation.y += 0.01;
            }
            splashRenderer.render(splashScene, splashCamera);
        }
        animateSplash();
    }

    function loadSplashCarModel() {
        if (!gltfLoader) return;
        gltfLoader.load('car1.glb', (gltf) => {
            splashCarModel = gltf.scene;
            splashCarModel.scale.set(1.7,1.7,1.7);
            splashCarModel.position.set(0,-0.5,0);
            splashScene.add(splashCarModel);
        });
    }

    // =============================================================================
    // ** æ¸¸æˆèµ„æºåŠ è½½ **
    // =============================================================================
    function loadCarModel() {
        gltfLoader.load('car1.glb', (gltf) => {
            carMesh = gltf.scene;
            // 3. è½¦èº«å†å¢å¤§ï¼šä» 1.7 å¢åŠ åˆ° 2.5
            carMesh.scale.set(2.5, 2.5, 2.5);
            carMesh.rotation.y = Math.PI;
            carMesh.position.y = -0.7; // è°ƒæ•´ä½ç½®ä»¥é€‚åº”æ–°çš„åº•ç›˜é«˜åº¦
            
            // ** ä¿®å¤æ‚¬ç©ºè½®å­ï¼šç§»é™¤æ¨¡å‹è‡ªå¸¦çš„è½®å­ **
            const objectsToRemove = [];
            carMesh.traverse((node) => {
                if (node.isMesh) {
                    node.castShadow = true;
                }
                // å¸¸è§çš„è½®å­å‘½ååŒ…æ‹¬ Wheel, Tire, Rim ç­‰
                const name = node.name.toLowerCase();
                if (name.includes('wheel') || name.includes('tire') || name.includes('rim')) {
                    objectsToRemove.push(node);
                }
            });

            // ç§»é™¤æ¨¡å‹è‡ªå¸¦çš„è½®å­ç½‘æ ¼ï¼Œåªä¿ç•™ç‰©ç†å¼•æ“é©±åŠ¨çš„è½®å­ç½‘æ ¼
            objectsToRemove.forEach(node => {
                if (node.parent) node.parent.remove(node);
            });
            // ** æ‚¬ç©ºè½®å­ä¿®å¤ç»“æŸ **

            scene.add(carMesh);

            // æ·»åŠ å°¾éƒ¨ç«ç„°ç‰¹æ•ˆ
            const flameGeometry = new THREE.ConeGeometry(0.3, 1, 16);
            const flameMaterial = new THREE.MeshBasicMaterial({ color: 0xff4500 });
            flameMesh = new THREE.Mesh(flameGeometry, flameMaterial);
            flameMesh.rotation.x = -Math.PI / 2; // ç«ç„°æœå
            flameMesh.position.set(0, 0, 2.5); // åœ¨è½¦å°¾åæ–¹
            flameMesh.visible = false;
            carMesh.add(flameMesh);
        });
    }

    function loadTireModel() {
        gltfLoader.load('tire1.glb', (gltf) => {
            tireMeshPrototype = gltf.scene;
            tireMeshPrototype.scale.set(0.75, 0.75, 0.75);
            tireMeshPrototype.rotation.x = Math.PI / 2;
            tireMeshPrototype.traverse((node) => {
                if (node.isMesh) node.castShadow = true;
            });
        });
    }

    function loadCity() {
        gltfLoader.load('city.glb', (gltf) => {
            const city = gltf.scene;
            city.traverse((node) => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                }
            });
            city.scale.set(4,4,4);
            scene.add(city);

            // å°†cityæ¨¡å‹è½¬æ¢ä¸ºCannon Trimeshç”¨äºç²¾ç¡®ç¢°æ’
            city.updateMatrixWorld(true);
            city.traverse((node) => {
                if (node.isMesh) {
                    const geometry = node.geometry.clone();
                    geometry.applyMatrix4(node.matrixWorld);
                    geometry.computeBoundingSphere();
                    const vertices = Array.from(geometry.attributes.position.array);
                    let indices = [];
                    if (geometry.index) {
                        indices = Array.from(geometry.index.array);
                    } else {
                        for (let i = 0; i < vertices.length/3; i++) indices.push(i);
                    }
                    const shape = new CANNON.Trimesh(vertices, indices);
                    const body = new CANNON.Body({ mass: 0 });
                    body.addShape(shape);
                    staticBodies.push({
                        body: body,
                        center: new THREE.Vector3().copy(geometry.boundingSphere.center),
                        radius: geometry.boundingSphere.radius,
                        added: false
                    });
                }
            });
        });
    }

    // =============================================================================
    // ** THREE.js/Cannon.js åŸºç¡€è®¾ç½® **
    // =============================================================================
    function initThree() {
        scene = new THREE.Scene();
        // 5. å»é™¤æ—¥å¤œï¼šå›ºå®šèƒŒæ™¯ä¸ºç™½å¤©
        scene.background = daySkyColor.clone();

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio || 1);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.BasicShadowMap;
        document.body.appendChild(renderer.domElement);
    }

    function initCannon() {
        world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);
        world.broadphase = new CANNON.SAPBroadphase(world);
        world.allowSleep = true;

        const defaultMaterial = new CANNON.Material('default');
        const contactMaterial = new CANNON.ContactMaterial(defaultMaterial, defaultMaterial, {
            friction: 2.5,
            restitution: 0.0
        });
        world.defaultContactMaterial = contactMaterial;
        world.addContactMaterial(contactMaterial);
    }

    function initGround() {
        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({
            mass: 0,
            material: world.defaultContactMaterial.material
        });
        groundBody.addShape(groundShape);
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        world.addBody(groundBody);

        const groundGeo = new THREE.PlaneGeometry(500, 500, 10, 10);
        const groundMat = new THREE.MeshPhongMaterial({ color: 0x444444 });
        const groundMesh = new THREE.Mesh(groundGeo, groundMat);
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.position.y = -0.05;
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);
    }

    function initCameraAndLights() {
        cameraChase = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        cameraCockpit = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
        activeCamera = cameraChase;

        // 5. å»é™¤æ—¥å¤œï¼šå›ºå®šå…‰ç…§ä¸ºç™½å¤©
        hemiLight = new THREE.HemisphereLight(dayHemiSky.clone(), dayHemiGround.clone(), 0.8);
        scene.add(hemiLight);

        dirLight = new THREE.DirectionalLight(0xfff0dd, 1.0);
        dirLight.position.set(50,100,50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 4096;
        dirLight.shadow.mapSize.height = 4096;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 500;
        dirLight.shadow.camera.left = -100;
        dirLight.shadow.camera.right = 100;
        dirLight.shadow.camera.top = 100;
        dirLight.shadow.camera.bottom = -100;
        scene.add(dirLight);
    }

    // 1. åº•ç›˜é™ä½ï¼Œä¼¸é•¿ï¼Œç¬¦åˆf1èµ›è½¦ã€‚
    function initVehicle() {
        // åº•ç›˜ï¼šå®½åº¦1ï¼Œé«˜åº¦0.3 (é™ä½)ï¼Œé•¿åº¦3 (ä¼¸é•¿) -> åŸä¸º 1, 0.5, 2
        const chassisShape = new CANNON.Box(new CANNON.Vec3(1, 0.3, 3));
        chassisBody = new CANNON.Body({
            mass: 1500,
            shape: chassisShape,
            // é™ä½åº•ç›˜ï¼šä» 1.0 é™ä½åˆ° 0.8
            position: new CANNON.Vec3(0, 0.8, 0)
        });
        // ** ä¿®å¤è½¬å‘é—®é¢˜ï¼šé™ä½è§’é˜»å°¼ï¼Œå‡å°‘å¯¹æ—‹è½¬çš„æŠ‘åˆ¶ **
        chassisBody.angularDamping = 0.1; // ä» 0.3 é™ä½
        chassisBody.linearDamping = 0.05;
        world.addBody(chassisBody);

        vehicle = new CANNON.RaycastVehicle({
            chassisBody: chassisBody,
            indexRightAxis: 0,
            indexUpAxis: 1,
            indexForwardAxis: 2
        });

        // è°ƒæ•´è½´è·å’Œè½®è·ä»¥é€‚åº”æ–°åº•ç›˜
        const axleWidth = 1.0;
        const wheelBase = 2.5; // å¢åŠ è½´è·
        function makeWheelOptions(x,y,z) {
            return {
                radius: 0.5,
                directionLocal: new CANNON.Vec3(0, -1, 0),
                suspensionStiffness: 50,
                suspensionRestLength: 0.3,
                frictionSlip: 2.5,
                dampingRelaxation: 1.5,
                dampingCompression: 2.5,
                maxSuspensionForce: 100000,
                // ** ä¿®å¤è½¬å‘é—®é¢˜ï¼šé™ä½æ¨ªå‘å½±å“åŠ›ï¼Œå‡å°‘ä¾§æ»‘æŠ‘åˆ¶ **
                rollInfluence: 0.1, // ä» 0.5 é™ä½
                maxSuspensionTravel: 0.3,
                customSlidingRotationalSpeed: -30,
                useCustomSlidingRotationalSpeed: true,
                axleLocal: new CANNON.Vec3(1, 0, 0),
                chassisConnectionPointLocal: new CANNON.Vec3(x, y, z)
            };
        }

        vehicle.addWheel(makeWheelOptions(-axleWidth, 0, wheelBase)); // å‰å·¦ (0)
        vehicle.addWheel(makeWheelOptions( axleWidth, 0, wheelBase)); // å‰å³ (1)
        vehicle.addWheel(makeWheelOptions(-axleWidth, 0, -wheelBase)); // åå·¦ (2)
        vehicle.addWheel(makeWheelOptions( axleWidth, 0, -wheelBase)); // åå³ (3)

        vehicle.addToWorld(world);

        wheelMeshes = [];
        if (tireMeshPrototype) {
            for (let i = 0; i < vehicle.wheelInfos.length; i++) {
                const wheelMesh = tireMeshPrototype.clone();
                wheelMeshes.push(wheelMesh);
                // ** ä¿®å¤æ‚¬ç©ºè½®å­ï¼šå°†ç½‘æ ¼è½®å­é™„åŠ åˆ°è½¦èº« **
                // carMesh è¿˜æ²¡æœ‰åœ¨åœºæ™¯ä¸­ï¼Œæ‰€ä»¥æˆ‘ä»¬ä»ç„¶æ·»åŠ åˆ° sceneï¼Œä½†åœ¨ updateCarMesh ä¸­æˆ‘ä»¬ä¿è¯äº† carMesh éšç‰©ç†è½¦èº«ç§»åŠ¨
                scene.add(wheelMesh);
            }
        } else {
            console.warn("Tire model not loaded, using fallback cylinder.");
            const wheelMat = new THREE.MeshPhongMaterial({ color: 0x111111 });
            for (let i = 0; i < vehicle.wheelInfos.length; i++) {
                const wheel = vehicle.wheelInfos[i];
                const cylinderGeometry = new THREE.CylinderGeometry(wheel.radius, wheel.radius, 0.2, 32);
                cylinderGeometry.rotateZ(Math.PI / 2);
                const wheelMesh = new THREE.Mesh(cylinderGeometry, wheelMat);
                wheelMeshes.push(wheelMesh);
                scene.add(wheelMesh);
            }
        }
    }

    // =============================================================================
    // ** æ¸¸æˆæ§åˆ¶ ä¸ HUD æ›´æ–° **
    // =============================================================================
    window.addEventListener('keydown', (event) => {
        switch(event.key.toLowerCase()) {
            case 'w': inputState.keyW = true; break;
            case 's': inputState.keyS = true; break;
            case 'a': inputState.keyA = true; break;
            case 'd': inputState.keyD = true; break;
            case ' ': inputState.keySpace = true; event.preventDefault(); break;
            case 'shift': inputState.keyShift = true; break;
            case 'v': toggleCamera(); break;
            case 'r': inputState.keyR = true; break; // **æ–°å¢ï¼šR é”®é‡ç”Ÿ**
        }
    });
    window.addEventListener('keyup', (event) => {
        switch(event.key.toLowerCase()) {
            case 'w': inputState.keyW = false; break;
            case 's': inputState.keyS = false; break;
            case 'a': inputState.keyA = false; break;
            case 'd': inputState.keyD = false; break;
            case ' ': inputState.keySpace = false; break;
            case 'shift': inputState.keyShift = false; break;
            case 'r': inputState.keyR = false; break; // **æ–°å¢ï¼šR é”®é‡ç”Ÿ**
        }
    });
    function toggleCamera() {
        if (activeCamera === cameraChase) {
            activeCamera = cameraCockpit;
        } else {
            activeCamera = cameraChase;
        }
    }

    function updateControls() {
        if (!chassisBody) return;
        engineForce = 0;
        let brake = 0;

        // **R é”®é‡ç”Ÿé€»è¾‘**
        if (inputState.keyR) {
            // é‡ç½®ä½ç½®
            chassisBody.position.set(0, 5, 0);
            // é‡ç½®æ—‹è½¬ (ä¿æŒæ°´å¹³ï¼Œæœå‘ Z è½´)
            chassisBody.quaternion.set(0, 0, 0, 1);
            // æ¸…é™¤çº¿é€Ÿåº¦å’Œè§’é€Ÿåº¦
            chassisBody.velocity.set(0, 0, 0);
            chassisBody.angularVelocity.set(0, 0, 0);
            // ç¡®ä¿ç‰©ç†å¼•æ“æ›´æ–°çŠ¶æ€
            chassisBody.wakeUp();

            inputState.keyR = false; // é‡ç½® R é”®çŠ¶æ€
            gearEl.textContent = 'P';
            
            // ç«‹å³é‡ç½®è½¬å‘å’Œé©±åŠ¨åŠ›ï¼Œé˜²æ­¢é‡ç½®æ—¶è½¦å­æ»‘åŠ¨
            vehicle.setSteeringValue(0, 0);
            vehicle.setSteeringValue(0, 1);
            vehicle.applyEngineForce(0, 0);
            vehicle.applyEngineForce(0, 1);
            vehicle.applyEngineForce(0, 2);
            vehicle.applyEngineForce(0, 3);

            return; // é‡ç”Ÿåç«‹å³é€€å‡ºï¼Œé¿å…æ‰§è¡Œå…¶ä»–æ§åˆ¶
        }


        const v = chassisBody.velocity;
        const currentSpeed = v.length() * 3.6;
        const chassisQuaternion = new THREE.Quaternion(chassisBody.quaternion.x, chassisBody.quaternion.y, chassisBody.quaternion.z, chassisBody.quaternion.w);
        const forwardVector = new THREE.Vector3(0, 0, 1).applyQuaternion(chassisQuaternion);
        const velocityVector = new THREE.Vector3(v.x, v.y, v.z);
        const isMovingForward = velocityVector.dot(forwardVector) > 0.5;
        const isMovingBackward = velocityVector.dot(forwardVector) < -0.5;

        // 4. å¹³æ»‘è½¬å‘è¾“å…¥ï¼ˆæ¸å˜ï¼‰
        if (inputState.keyA) {
            targetSteeringValue = maxSteerVal;
        } else if (inputState.keyD) {
            targetSteeringValue = -maxSteerVal;
        } else {
            targetSteeringValue = 0;
        }
        // ä½¿ç”¨ lerp (çº¿æ€§æ’å€¼) æ¥å¹³æ»‘è½¬å‘å€¼
        steeringValue = steeringValue + (targetSteeringValue - steeringValue) * steeringSmoothFactor;


        // åŠ é€Ÿ / å€’è½¦
        if (inputState.keyW) {
            if (isMovingBackward) {
                brake = maxEngineForce * 0.5;
            } else {
                engineForce = -maxEngineForce;
                gearEl.textContent = 'D';
            }
        } else if (inputState.keyS) {
            if (isMovingForward) {
                brake = maxEngineForce * 0.5;
            } else {
                engineForce = maxEngineForce * 0.5;
                gearEl.textContent = 'R';
            }
        } else if (!inputState.keySpace) {
            if (currentSpeed < 1) {
                gearEl.textContent = 'P';
            } else {
                gearEl.textContent = 'N';
            }
        }

        // è½¬å‘å€¼åº”ç”¨ï¼šä»…å‰è½®è½¬å‘ (0, 1)
        vehicle.setSteeringValue(steeringValue, 0); // å‰å·¦è½®
        vehicle.setSteeringValue(steeringValue, 1); // å‰å³è½®
        // åè½®ä¸è½¬å‘
        vehicle.setSteeringValue(0, 2); // åå·¦è½®
        vehicle.setSteeringValue(0, 3); // åå³è½®


        // ** ä¿®å¤è½¬å‘é—®é¢˜ï¼šå°†é©±åŠ¨åŠ›æ”¹ä¸ºåé©±ä¸ºä¸»ï¼ˆå‡å°å‰è½®æ¨å¤´ï¼‰**
        const frontWheelForce = engineForce * 0.2; // å‰è½®åªæä¾› 20% é©±åŠ¨åŠ›
        const rearWheelForce = engineForce;        // åè½®æä¾› 100% é©±åŠ¨åŠ›

        vehicle.applyEngineForce(frontWheelForce, 0); // å‰å·¦è½® (0)
        vehicle.applyEngineForce(frontWheelForce, 1); // å‰å³è½® (1)
        vehicle.applyEngineForce(rearWheelForce, 2);  // åå·¦è½® (2)
        vehicle.applyEngineForce(rearWheelForce, 3);  // åå³è½® (3)


        // åˆ¹è½¦
        let finalBrakeFL = brake, finalBrakeFR = brake, finalBrakeRL = brake, finalBrakeRR = brake;
        if (inputState.keySpace) {
            const handbrakeStrength = maxEngineForce * 0.8;
            finalBrakeRL = handbrakeStrength;
            finalBrakeRR = handbrakeStrength;
            gearEl.textContent = 'E';
        }
        
        // åº”ç”¨åˆ¹è½¦
        vehicle.setBrake(finalBrakeFL, 0);
        vehicle.setBrake(finalBrakeFR, 1);
        vehicle.setBrake(finalBrakeRL, 2);
        vehicle.setBrake(finalBrakeRR, 3);

        // æ¸…é™¤åˆ¹è½¦ï¼Œé˜²æ­¢è¯¯åˆ¹
        if (finalBrakeFL === 0 && finalBrakeRL === 0 && !inputState.keySpace) {
             vehicle.setBrake(0, 0);
             vehicle.setBrake(0, 1);
             vehicle.setBrake(0, 2);
             vehicle.setBrake(0, 3);
        }

        // å¢å¼ºåŠŸèƒ½ï¼šShift é”®åŠ é€Ÿ
        if (inputState.keyShift && engineForce !== 0) {
            engineForce *= 3;
            if (flameMesh) flameMesh.visible = true;
        } else {
            if (flameMesh) flameMesh.visible = false;
        }
    }

    function updateCamera() {
        if (!chassisBody) return;
        const chassisPos = new THREE.Vector3().copy(chassisBody.position);
        const q = chassisBody.quaternion;
        if (activeCamera === cameraChase) {
            const offset = new THREE.Vector3(0, 3, -7);
            offset.applyQuaternion(q);
            offset.add(chassisPos);
            cameraChase.position.lerp(offset, 0.1);
            cameraChase.lookAt(chassisPos.x, chassisPos.y + 1, chassisPos.z);
        } else {
            const offset = new THREE.Vector3(0, 0.8, 1.5);
            offset.applyQuaternion(q);
            offset.add(chassisPos);
            cameraCockpit.position.copy(offset);
            cameraCockpit.quaternion.copy(q);
            const rotation180 = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), Math.PI);
            cameraCockpit.quaternion.multiply(rotation180);
        }
    }

    function updateWheelMeshes() {
        for (let i = 0; i < vehicle.wheelInfos.length; i++) {
            vehicle.updateWheelTransform(i);
            const t = vehicle.wheelInfos[i].worldTransform;
            if (wheelMeshes[i]) {
                wheelMeshes[i].position.copy(t.position);
                wheelMeshes[i].quaternion.copy(t.quaternion);
            }
        }
    }

    function updateCarMesh() {
        if (chassisBody && carMesh) {
            carMesh.position.copy(chassisBody.position);
            carMesh.quaternion.copy(chassisBody.quaternion);
        }
    }

    function updateHUD() {
        if (!chassisBody) return;
        const v = chassisBody.velocity;
        const speed = v.length() * 3.6;
        speedEl.textContent = speed.toFixed(0);
        altitudeEl.textContent = chassisBody.position.y.toFixed(0);
        const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(chassisBody.quaternion);
        const heading = Math.atan2(forward.x, forward.z) * 180 / Math.PI;
        let h = (heading + 360) % 360;
        headingEl.textContent = h.toFixed(0).padStart(3, '0');
        const rpm = Math.min(75, Math.floor(speed * 2.0));
        rpmEl.textContent = rpm;
        // ä½¿ç”¨å¹³æ»‘åçš„ steeringValue æ¥è®¡ç®—è§’åº¦
        const steerDegrees = (steeringValue / maxSteerVal * 30).toFixed(0); 
        steerEl.textContent = steerDegrees + 'Â°';
        let throttlePercent = 0;
        // æ³¨æ„ï¼šè®¡ç®—æ²¹é—¨ç™¾åˆ†æ¯”æ—¶ï¼Œä½¿ç”¨åŸæœ¬çš„ maxEngineForce
        if (engineForce !== 0) {
            throttlePercent = Math.abs((engineForce / maxEngineForce) * 100).toFixed(0);
        }
        throttleEl.textContent = throttlePercent + '%';
    }

    function updateColliders() {
        if (!chassisBody) return;
        const chassisPos = new THREE.Vector3(chassisBody.position.x, chassisBody.position.y, chassisBody.position.z);
        staticBodies.forEach(obj => {
            const d = chassisPos.distanceTo(obj.center);
            // æ‰©å¤§åŠ è½½èŒƒå›´
            if (!obj.added && d <= obj.radius + 10) { 
                world.addBody(obj.body);
                obj.added = true;
            } else if (obj.added && d > obj.radius + 15) {
                world.removeBody(obj.body);
                obj.added = false;
            }
        });
    }

    function animate(time) {
        requestAnimationFrame(animate);
        if (!chassisBody || !world) return;
        const fixedTimeStep = 1/60;
        const maxSubSteps = 1;
        if (lastTime !== undefined) {
            const dt = (time - lastTime) / 1000;
            world.step(fixedTimeStep, dt, maxSubSteps);
        } else {
            world.step(fixedTimeStep);
        }
        lastTime = time;

        updateControls();
        updateWheelMeshes();
        updateCarMesh();
        updateCamera();
        updateHUD();
        updateColliders();

        renderer.render(scene, activeCamera);
    }

    // =============================================================================
    // ** å¯åŠ¨é€»è¾‘ **
    // =============================================================================
    function startGame() {
        document.getElementById('splash').style.display = 'none';
        document.getElementById('loading-screen').style.display = 'flex';
        setupGame();
    }
    window.startGame = startGame;

    function setupGame() {
        initThree();
        initCannon();
        initGround();
        initCameraAndLights();
        initLoaders();
        loadCarModel();
        loadTireModel();
        loadCity();
    }

    window.addEventListener('resize', () => {
        if (renderer && cameraChase && cameraCockpit) {
            renderer.setSize(window.innerWidth, window.innerHeight);
            const aspect = window.innerWidth / window.innerHeight;
            cameraChase.aspect = aspect;
            cameraChase.updateProjectionMatrix();
            cameraCockpit.aspect = aspect;
            cameraCockpit.updateProjectionMatrix();
        }
        if (splashRenderer && splashCamera) {
            const container = document.getElementById('splash-three-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            splashRenderer.setSize(width, height);
            splashCamera.aspect = width / height;
            splashCamera.updateProjectionMatrix();
        }
    });

    document.addEventListener('DOMContentLoaded', () => {
        initLoaders();
        initSplashThree();
        loadSplashCarModel();
    });
    </script>
</body>
</html>
