<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <title>OPEN WORLD HYPER DRIVE - POLICE CHASE</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* =========================================================================
         * UI BASE & TYPOGRAPHY
         * ========================================================================= */
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000000; 
            font-family: 'Rajdhani', sans-serif; 
            color: #E0FFFF;
            user-select: none; 
            -webkit-user-select: none;
            touch-action: none; 
        }
        
        /* =========================================================================
         * HUD (IN-GAME INTERFACE)
         * ========================================================================= */
        #hud-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
            padding: 30px; box-sizing: border-box; z-index: 10;
        }

        .hud-top-left { display: flex; gap: 20px; flex-wrap: wrap; }
        .hud-top-right { position: absolute; top: 30px; right: 30px; }
        
        .instrument {
            background: rgba(0, 15, 30, 0.7);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-left: 5px solid #00FFFF;
            backdrop-filter: blur(10px);
            padding: 12px 22px;
            min-width: 120px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.1);
            border-radius: 4px;
            clip-path: polygon(0 0, 100% 0, 100% 80%, 90% 100%, 0 100%);
        }
        
        .label {
            font-family: 'Orbitron', sans-serif; font-size: 10px; color: #00FFFF; 
            font-weight: 700; letter-spacing: 2px; margin-bottom: 3px; display:block; 
            text-transform: uppercase; text-shadow: 0 0 5px rgba(0, 255, 255, 0.8);
        }
        .value {
            font-family: 'Orbitron', sans-serif; font-size: 36px; font-weight: 900; 
            letter-spacing: -2px; line-height: 1; color: #FFFFFF;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }
        .unit { font-size: 14px; color: #888888; margin-left: 6px; font-weight: 400; }

        .spd-color { border-left-color: #00FFFF !important; }
        .rpm-color { border-left-color: #FF00FF !important; }
        .gear-color { border-left-color: #FFD700 !important; }
        .throttle-color { border-left-color: #00FF00 !important; }

        #hud-coin {
            background: rgba(35, 18, 0, 0.7);
            border: 1px solid rgba(255, 215, 0, 0.15);
            border-left: 5px solid #FFD700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.06);
            min-width: 140px; margin-bottom: 20px;
        }
        #hud-coin .label { color: #FFD700; }
        #coin-count { font-size: 40px; letter-spacing: 2px; color: #FFD700; }

        /* ** Delivery HUD Style ** */
        #delivery-hud {
            position: absolute; top: 180px; left: 30px;
            background: rgba(0, 30, 0, 0.7);
            border: 1px solid rgba(0, 255, 0, 0.2);
            border-left: 5px solid #00FF00;
            backdrop-filter: blur(10px);
            padding: 15px 20px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.1);
            border-radius: 4px;
            min-width: 250px;
            display: none; 
        }
        #delivery-hud .mission-title { 
            font-family: 'Orbitron', sans-serif; font-size: 14px; color: #00FF00; 
            margin-bottom: 8px; font-weight: 700; border-bottom: 1px dashed rgba(0, 255, 0, 0.3);
            padding-bottom: 5px;
        }
        #delivery-hud .mission-detail { font-size: 16px; color: #E0FFE0; margin-bottom: 5px; }
        #delivery-distance-value { font-family: 'Orbitron', sans-serif; font-weight: 900; font-size: 24px; color: #FFFFFF; }
        #delivery-timer-value { font-family: 'Orbitron', sans-serif; font-weight: 900; font-size: 24px; color: #FFD700; }

        /* ** Police HUD Style ** */
        #police-hud {
            position: absolute; top: 120px; left: 50%; transform: translateX(-50%);
            text-align: center; display: none;
        }
        #police-alert {
            font-family: 'Orbitron', sans-serif; font-size: 28px; font-weight: 900;
            color: #FF0000; text-shadow: 0 0 15px red; letter-spacing: 3px;
            animation: blinkRed 0.5s infinite alternate;
        }
        #police-timer {
            font-family: 'Orbitron'; font-size: 20px; color: #fff; margin-top: 5px;
        }
        @keyframes blinkRed { from { opacity: 1; } to { opacity: 0.3; } }

        /* ** BUSTED SCREEN ** */
        #busted-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 50, 0.8); z-index: 2000; display: none;
            flex-direction: column; align-items: center; justify-content: center;
        }
        #busted-text {
            font-family: 'Orbitron'; font-size: 100px; color: #FF0000; font-weight: 900;
            text-shadow: 0 0 30px #FF0000; transform: rotate(-10deg); border: 5px solid red;
            padding: 10px 40px; letter-spacing: 10px;
        }
        #busted-restart-btn {
            margin-top: 50px; padding: 20px 60px; font-size: 24px; font-family: 'Orbitron';
            background: white; border: none; cursor: pointer; font-weight: bold;
        }

        #control-hints {
            position: absolute; bottom: 30px; left: 30px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-left: 5px solid #00FF00;
            backdrop-filter: blur(10px); padding: 18px 25px;
            color: #eee; font-size: 13px; border-radius: 4px;
            max-width: 250px; line-height: 1.8;
        }
        .respawn-hint { color: #FFD700; font-weight: bold; }
        .hint-title { color: #00FF00; font-family: 'Orbitron', sans-serif; font-weight: bold; margin-bottom: 10px; border-bottom: 1px solid rgba(0, 255, 0, 0.3); padding-bottom: 5px; }
        .copyright-tag { position: fixed; bottom: 15px; right: 15px; font-size: 12px; color: rgba(255, 255, 255, 0.3); z-index: 10; }

        /* =========================================================================
         * MOBILE CONTROLS
         * ========================================================================= */
        #mobile-controls {
            display: none; 
            position: absolute; bottom: 20px; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 20;
        }
        .touch-btn {
            position: absolute; pointer-events: auto;
            background: rgba(0, 255, 255, 0.15); border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 50%; width: 80px; height: 80px;
            backdrop-filter: blur(4px); touch-action: none;
            display: flex; align-items: center; justify-content: center;
        }
        .touch-btn:active { background: rgba(0, 255, 255, 0.5); }
        .touch-btn svg { width: 40px; height: 40px; fill: #fff; }
        
        #btn-left { bottom: 30px; left: 30px; }
        #btn-right { bottom: 30px; left: 130px; }
        #btn-brake { bottom: 30px; right: 140px; width: 60px; height: 60px; border-color: #ff0055; background: rgba(255, 0, 85, 0.2); }
        #btn-gas { bottom: 40px; right: 30px; width: 90px; height: 90px; border-color: #00ff00; background: rgba(0, 255, 0, 0.2); }
        #btn-respawn-mob { top: 100px; right: 20px; width: 50px; height: 50px; border-radius: 8px; font-family: 'Orbitron'; font-weight: bold; color: yellow; border-color: yellow;}
        #btn-camera-mob { top: 100px; left: 20px; width: 50px; height: 50px; border-radius: 8px; font-family: 'Orbitron'; font-weight: bold; color: cyan; }

        /* =========================================================================
         * SPLASH / MAIN MENU UI
         * ========================================================================= */
        #splash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(0,0,0,0.6) 0%, rgba(0,0,0,0) 30%, rgba(0,0,0,0) 70%, rgba(0,0,0,0.8) 100%);
            z-index: 999;
            display: none; 
            cursor: grab;
            transition: opacity 0.5s; 
        }
        #splash:active { cursor: grabbing; }

        .splash-header {
            position: absolute; top: 60px; left: 0; width: 100%;
            text-align: center; pointer-events: none;
        }
        h1 {
            font-family: 'Orbitron', sans-serif; font-size: 64px; margin: 0; font-weight: 900;
            letter-spacing: 12px; text-transform: uppercase;
            background: linear-gradient(to right, #00FFFF, #FFFFFF, #FF00FF);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 0 35px rgba(0, 255, 255, 0.7), 0 0 5px rgba(255, 255, 255, 0.5);
        }
        .splash-subtitle {
            font-family: 'Rajdhani', sans-serif; font-size: 20px; color: rgba(0, 255, 255, 0.8);
            letter-spacing: 6px; margin-top: 10px; font-weight: 600;
        }

        .splash-top-right {
            position: absolute; top: 40px; right: 40px;
            text-align: right; pointer-events: none;
        }
        .splash-top-right .label { font-size: 12px; color: #FFD700; text-shadow: 0 0 10px #FFD700; margin-bottom: 5px;}
        .splash-top-right .value { font-size: 42px; color: #FFD700; text-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }

        .splash-left-menu {
            position: absolute; top: 50%; left: 40px;
            transform: translateY(-50%);
            display: flex; flex-direction: column; gap: 20px;
            pointer-events: auto; 
            z-index: 1000;
        }
        .menu-btn {
            font-family: 'Orbitron', sans-serif; font-size: 16px; font-weight: 700;
            color: rgba(255,255,255,0.7); background: rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.2); border-left: 3px solid #888;
            padding: 12px 30px; letter-spacing: 3px; cursor: pointer;
            transition: 0.3s; width: 200px; text-align: left;
            clip-path: polygon(0 0, 100% 0, 95% 100%, 0 100%);
        }
        .menu-btn:hover {
            background: rgba(0, 255, 255, 0.2); color: #fff;
            border-left-color: #00FFFF; padding-left: 40px;
            box-shadow: 0 0 15px rgba(0,255,255,0.3);
        }

        .splash-footer {
            position: absolute; bottom: 60px; right: 60px;
            display: flex; gap: 20px; align-items: flex-end;
            pointer-events: none; 
        }
        
        .splash-footer button { pointer-events: auto; font-family: 'Orbitron', sans-serif; cursor: pointer; transition: 0.3s; }

        #start-button {
            padding: 20px 80px; font-size: 24px; font-weight: 900;
            color: #000000; background: #00FFFF; border: none;
            letter-spacing: 4px; box-shadow: 0 0 30px rgba(0, 255, 255, 0.6);
            clip-path: polygon(10% 0, 100% 0, 90% 100%, 0 100%);
        }
        #start-button:hover {
            background: #FF00FF; box-shadow: 0 0 50px rgba(255, 0, 255, 0.8); color: #fff; transform: scale(1.05);
        }

        #delivery-mode-btn { 
            padding: 15px 40px; font-size: 16px; font-weight: 700;
            color: #00FFFF; background: rgba(0, 20, 40, 0.8);
            border: 1px solid #00FFFF; letter-spacing: 2px;
            clip-path: polygon(10% 0, 100% 0, 100% 100%, 0 100%, 0 20%);
        }
        #delivery-mode-btn:hover {
            background: rgba(0, 255, 255, 0.2); box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        #police-mode-btn { 
            padding: 15px 40px; font-size: 16px; font-weight: 700;
            color: #FF0055; background: rgba(40, 0, 0, 0.8);
            border: 1px solid #FF0055; letter-spacing: 2px;
            clip-path: polygon(10% 0, 100% 0, 100% 100%, 0 100%, 0 20%);
        }
        #police-mode-btn:hover {
            background: rgba(255, 0, 85, 0.2); box-shadow: 0 0 20px rgba(255, 0, 85, 0.3);
        }

        /* Loading Screen */
        #loading-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; color: #00FFFF; z-index: 1000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.5s;
        }
        #loading-progress-bar { width: 400px; height: 5px; background: #222; margin-top: 20px; border-radius: 2px; overflow: hidden; }
        #loading-progress-fill { height: 100%; width: 0%; background: #00FFFF; box-shadow: 0 0 10px #00FFFF; transition: width 0.3s; }

        /* =========================================================================
         * New Menu Pages
         * ========================================================================= */
        .menu-page {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 9999;
            display: none; 
            align-items: center; justify-content: center;
            flex-direction: column;
            padding: 40px;
            box-sizing: border-box;
            backdrop-filter: blur(8px);
            opacity: 0;
            transition: opacity 0.4s;
        }
        .menu-page.active { opacity: 1; display: flex; }
        .menu-page h2 {
            font-family: 'Orbitron', sans-serif; font-size: 48px; color: #FF00FF;
            text-shadow: 0 0 15px rgba(255, 0, 255, 0.8);
            margin-bottom: 20px;
            text-transform: uppercase;
        }
        .menu-page p {
            font-size: 20px; color: #E0FFFF; line-height: 1.6;
            max-width: 600px; text-align: center;
        }
        .menu-page .detail-line {
            font-family: 'Rajdhani', sans-serif; font-size: 22px; margin: 10px 0;
            text-align: left; width: 100%; max-width: 400px;
            border-bottom: 1px dotted rgba(255, 255, 255, 0.2);
            padding-bottom: 5px;
        }
        .menu-page .detail-line strong {
            color: #00FFFF; margin-right: 15px; font-weight: 700;
        }
        #menu-close-btn {
            position: absolute; top: 40px; right: 40px;
            background: #FF00FF; color: #000; border: none;
            padding: 12px 25px; 
            font-family: 'Orbitron', sans-serif;
            font-weight: 70s0; cursor: pointer; transition: 0.2s;
            clip-path: polygon(20% 0, 100% 0, 80% 100%, 0 100%);
        }
        #menu-close-btn:hover {
            background: #00FFFF; box-shadow: 0 0 15px #00FFFF; transform: scale(1.05);
        }

        .shop-grid { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; margin-top: 20px;}
        .shop-item {
            background: rgba(0, 20, 40, 0.8); border: 1px solid #00FFFF;
            padding: 20px; width: 220px; text-align: center;
            display: flex; flex-direction: column; align-items: center;
            transition: 0.3s; position: relative;
        }
        .shop-item:hover { transform: translateY(-5px); box-shadow: 0 0 20px rgba(0, 255, 255, 0.3); }
        .shop-item h3 { margin: 0 0 10px 0; color: #FFD700; font-family: 'Orbitron'; }
        .shop-item .price { font-size: 24px; color: #fff; font-weight: bold; margin: 10px 0; }
        .shop-item button {
            background: #00FFFF; border: none; padding: 10px 20px; font-family: 'Orbitron'; font-weight: bold; cursor: pointer; width: 100%;
        }
        .shop-item button:disabled { background: #555; color: #888; cursor: not-allowed; }
        .shop-item.owned { border-color: #00FF00; }
        .shop-item.owned button { background: #00FF00; color: #000; }

        #drift-bonus {
            position: absolute; top: 30%; left: 50%; transform: translateX(-50%);
            font-family: 'Orbitron'; font-style: italic; font-weight: 900;
            font-size: 48px; color: #FFD700; text-shadow: 0 0 20px orange;
            display: none; pointer-events: none; z-index: 15;
        }

    </style>
</head>
<body>

    <div id="loading-screen">
        <h2 style="margin:0; font-size:32px; color:white; font-family:'Orbitron';">SYSTEM INITIALIZING</h2>
        <p style="font-family:'Orbitron'; letter-spacing:2px;">HYPER DRIVE</p>
        <div id="loading-progress-bar"><div id="loading-progress-fill"></div></div>
        <p id="loading-status" style="margin-top:10px; font-size:14px; font-family:'Rajdhani';">(0%) Loading Assets...</p> 
    </div>

    <div id="busted-screen">
        <div id="busted-text">BUSTED</div>
        <p style="color:white; font-family:'Orbitron'; font-size:20px; margin-top:20px;">POLICE CAUGHT YOU</p>
        <button id="busted-restart-btn" onclick="location.reload()">RESTART SYSTEM</button>
    </div>

    <div id="shop-page" class="menu-page">
        <button id="menu-close-btn" onclick="hideMenuPages()">MAIN MENU</button>
        <h2>PERFORMANCE SHOP</h2>
        <div style="text-align:center; margin-bottom:10px;">
            <span style="color:#FFD700; font-family:'Orbitron'; font-size:24px;">YOUR GOLD: <span id="shop-coin-display">0</span></span>
        </div>
        <div class="shop-grid">
            <div class="shop-item" id="item-engine">
                <h3>TURBO ENGINE</h3>
                <p style="font-size:14px; color:#aaa;">Increase Top Speed & Acceleration</p>
                <div class="price">1 G</div>
                <button onclick="buyUpgrade('engine', 1)">BUY UPGRADE</button>
            </div>
            <div class="shop-item" id="item-gold">
                <h3>GOLD SCANNER</h3>
                <p style="font-size:14px; color:#aaa;">Double all gold collected</p>
                <div class="price">1 G</div>
                <button onclick="buyUpgrade('gold', 1)">BUY UPGRADE</button>
            </div>
             <div class="shop-item" id="item-paint">
                <h3>NEON PAINT</h3>
                <p style="font-size:14px; color:#aaa;">Special Cyberpunk Red Skin</p>
                <div class="price">1 G</div>
                <button onclick="buyUpgrade('paint', 1)">UNLOCK</button>
            </div>
        </div>
        <p style="margin-top:20px; font-size:14px; color:#888;">Items are saved automatically.</p>
    </div>

    <div id="settings-page" class="menu-page">
        <button id="menu-close-btn" onclick="hideMenuPages()">BACK TO MENU</button>
        <h2>GAME SETTINGS</h2>
        <p>Audio is enabled by default.</p>
        <p>Touch controls are enabled on mobile devices.</p>
        <div class="detail-line" style="text-align:center;"><strong>VERSION:</strong> 1.2 (POLICE UPDATE)</div>
    </div>

    <div id="info-page" class="menu-page">
        <button id="menu-close-btn" onclick="hideMenuPages()">MAIN MENU</button>
        <h2>SYSTEM INFO</h2>
        <div style="margin-top: 20px;">
            <div class="detail-line"><strong>AUTHOR:</strong> ZHANYI ZHOU</div>
            <div class="detail-line"><strong>EMAIL</strong> z03640940@gmail.com</div>
            <div class="detail-line"><strong>GAME NAME:</strong> OPEN WORLD HYPER DRIVE</div>
            <div class="detail-line"><strong>ENGINE:</strong> HTML5 (THREE.js + CANNON.js)</div>
            <div class="detail-line"><strong>VERSION</strong> V 1.2</div>
        </div>
    </div>

    <div id="splash">
        <div class="splash-header">
            <h1>OPEN WORLD<br>HYPER DRIVE</h1>
            <p class="splash-subtitle">MADE BY ZHANYI ZHOU</p>
        </div>

        <div class="splash-top-right">
            <span class="label">GOLD COINS</span><br>
            <span class="value" id="splash-coin-count">0</span>
        </div>

        <div class="splash-left-menu">
            <button class="menu-btn" onclick="showMenuPage('shop-page')">SHOP</button>
            <button class="menu-btn" onclick="showMenuPage('settings-page')">SETTINGS</button>
            <button class="menu-btn" onclick="showMenuPage('info-page')">INFO</button>
        </div>

        <div class="splash-footer">
            <button id="police-mode-btn" onclick="startPoliceMode()">POLICE CHASE</button>
            <button id="delivery-mode-btn" onclick="startDeliveryMode()">DELIVERY MODE</button>
            <button id="start-button" onclick="enterGame()">FREEROAM</button>
        </div>
    </div>

    <div class="copyright-tag">ZHANYI ZHOU DESIGN © 2025</div>

    <div id="hud-layer" style="display:none;">
        <div class="hud-top-left">
            <div class="instrument spd-color">
                <span class="label">Speed</span> <span class="value" id="hud-spd">0</span> <span class="unit">KM/H</span>
            </div>
            <div class="instrument rpm-color">
                <span class="label">RPM</span> <span class="value" id="hud-rpm">0</span> <span class="unit">x100</span>
            </div>
            <div class="instrument gear-color">
                <span class="label">Gear</span> <span class="value" id="hud-gear">P</span> <span class="unit">MODE</span>
            </div>
            <div class="instrument throttle-color">
                <span class="label">Throttle</span> <span class="value" id="hud-throttle">0%</span>
            </div>
            <div class="instrument">
                <span class="label">Altitude</span> <span class="value" id="hud-alt">0</span> <span class="unit">M</span>
            </div>
            <div class="instrument">
                <span class="label">Heading</span> <span class="value" id="hud-hdg">000</span> <span class="unit">DEG</span>
            </div>
        </div>

        <div class="hud-top-right">
            <div class="instrument" id="hud-coin">
                <span class="label">GOLD COIN</span> <span class="value" id="coin-count">0</span>
            </div>
        </div>
        
        <div id="delivery-hud">
            <div class="mission-title" id="mission-status-text">MISSION: OFFLINE</div>
            <div class="mission-detail">DISTANCE: <span id="delivery-distance-value">0</span> M</div>
            <div class="mission-detail">TIME LEFT: <span id="delivery-timer-value">--:--</span></div>
        </div>

        <div id="police-hud">
            <div id="police-alert">POLICE INBOUND</div>
            <div id="police-timer">T-MINUS 10s</div>
        </div>

        <div id="drift-bonus">DRIFT BONUS! +10</div>

        <div class="hud-bottom">
            <div id="control-hints">
                <div class="hint-title">SYSTEM CONTROLS</div>
                <div>[SHIFT] NITRO BOOST</div>
                <div>[SPACE] DRIFT / BRAKE</div>
                <div>[V] CHANGE CAMERA</div>
                <div class="respawn-hint">[R] RESPAWN CAR</div>
                <div>[WASD] DRIVE</div>
            </div>
        </div>

        <div id="mobile-controls">
            <div class="touch-btn" id="btn-left">
                <svg viewBox="0 0 24 24"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/></svg>
            </div>
            <div class="touch-btn" id="btn-right">
                <svg viewBox="0 0 24 24"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/></svg>
            </div>
            <div class="touch-btn" id="btn-brake">
                <svg viewBox="0 0 24 24"><path d="M6 6h12v12H6z"/></svg>
            </div>
            <div class="touch-btn" id="btn-gas">
                <svg viewBox="0 0 24 24"><path d="M12 2L4.5 20.29l.71.71L12 18l6.79 3 .71-.71z"/></svg>
            </div>
            <div class="touch-btn" id="btn-respawn-mob">R</div>
            <div class="touch-btn" id="btn-camera-mob">CAM</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>

    <script>
    // =============================================================================
    // ** GAME DATA & PERSISTENCE **
    // =============================================================================
    let gameData = {
        coins: 0,
        upgrades: {
            engine: 0,
            gold: 0,
            paint: 0
        }
    };

    function loadGameData() {
        const stored = localStorage.getItem('hyperDriveSave');
        if (stored) {
            try {
                const parsed = JSON.parse(stored);
                gameData = { ...gameData, ...parsed };
                if(parsed.upgrades) gameData.upgrades = { ...gameData.upgrades, ...parsed.upgrades };
            } catch(e) { console.error("Save file corrupt, resetting."); }
        }
        updateUIValues();
    }

    function saveGameData() {
        localStorage.setItem('hyperDriveSave', JSON.stringify(gameData));
        updateUIValues();
    }

    function updateUIValues() {
        document.getElementById('splash-coin-count').textContent = gameData.coins;
        document.getElementById('coin-count').textContent = gameData.coins;
        document.getElementById('shop-coin-display').textContent = gameData.coins;
        
        updateShopItemState('item-engine', gameData.upgrades.engine > 0);
        updateShopItemState('item-gold', gameData.upgrades.gold > 0);
        updateShopItemState('item-paint', gameData.upgrades.paint > 0);
    }

    function updateShopItemState(id, isOwned) {
        const el = document.getElementById(id);
        const btn = el.querySelector('button');
        if (isOwned) {
            el.classList.add('owned');
            btn.textContent = "OWNED";
            btn.disabled = true;
        }
    }

    // =============================================================================
    // ** SHOP LOGIC **
    // =============================================================================
    window.buyUpgrade = function(type, cost) {
        if (gameData.coins >= cost) {
            if (gameData.upgrades[type] === 0) {
                gameData.coins -= cost;
                gameData.upgrades[type] = 1;
                saveGameData();
                alert("UPGRADE SUCCESSFUL!");
                applyUpgrades();
            } else {
                alert("You already own this!");
            }
        } else {
            alert("NOT ENOUGH GOLD!");
        }
    }
    
    // =============================================================================
    // ** AUDIO SYSTEM **
    // =============================================================================
    let audioCtx;
    let engineOsc, engineGain;
    let audioEnabled = false;

    function initAudio() {
        if(!audioCtx) {
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AudioContext();
                
                engineOsc = audioCtx.createOscillator();
                engineOsc.type = 'sawtooth';
                engineOsc.frequency.value = 100;
                
                engineGain = audioCtx.createGain();
                engineGain.gain.value = 0;
                
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 400;

                engineOsc.connect(filter);
                filter.connect(engineGain);
                engineGain.connect(audioCtx.destination);
                
                engineOsc.start();
                audioEnabled = true;
            } catch (e) { console.warn("Audio init failed", e); }
        } else if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
    }

    function updateEngineSound(speed, isGas) {
        if(!audioEnabled || !engineOsc) return;
        const minFreq = 80;
        const maxFreq = 400;
        const speedFactor = Math.min(speed / 200, 1);
        
        const targetFreq = minFreq + (speedFactor * (maxFreq - minFreq));
        engineOsc.frequency.setTargetAtTime(targetFreq, audioCtx.currentTime, 0.1);
        
        let targetVol = 0.05 + (speedFactor * 0.1);
        if(isGas) targetVol += 0.05;
        engineGain.gain.setTargetAtTime(targetVol, audioCtx.currentTime, 0.1);
    }

    function playCoinSound() {
        if(!audioEnabled) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(1200, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(2000, audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
        
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.3);
    }

    function playSirenSound() {
        // Simple synth siren for police
        if(!audioEnabled) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const delay = audioCtx.createDelay(0.5);
        const feedback = audioCtx.createGain();

        osc.type = 'square';
        osc.start();
        
        gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
        
        feedback.gain.setValueAtTime(0.5, audioCtx.currentTime);
        delay.delayTime.setValueAtTime(0.1, audioCtx.currentTime);

        osc.connect(delay);
        delay.connect(feedback);
        feedback.connect(delay);
        delay.connect(gain);
        gain.connect(audioCtx.destination);
        
        // Siren sound: sweep frequency
        const sweep = (freq1, freq2, duration) => {
            osc.frequency.setValueAtTime(freq1, audioCtx.currentTime);
            osc.frequency.linearRampToValueAtTime(freq2, audioCtx.currentTime + duration);
            osc.frequency.linearRampToValueAtTime(freq1, audioCtx.currentTime + duration * 2);
        };
        
        // Loop the sweep
        const interval = 0.8;
        let timer = audioCtx.currentTime;
        for(let i=0; i<100; i++){ // Play for a long time
            sweep(440, 660, interval);
            timer += interval * 2;
        }

        osc.stop(audioCtx.currentTime + 100); // Stop after a long time, managed by police mode logic
        return { osc: osc, gain: gain }; // Return components to control volume/stop later
    }


    // =============================================================================
    // ** THREE.JS & CANNON.JS SETUP **
    // =============================================================================
    let scene, renderer, cameraChase, cameraCockpit, currentCamera;
    let world;
    let vehicle, chassisBody, wheelMeshes = [];
    let isGameRunning = false;
    let isDragging = false;
    let lastTime = undefined;
    let cameraMode = 'chase'; // 'chase' or 'cockpit'
    let splashCameraAngle = 0;
    let previousMouseX = 0;

    const daySkyColor = new THREE.Color(0x87CEEB);
    const dayHemiSky = new THREE.Color(0xffffff);
    const dayHemiGround = new THREE.Color(0x3b4c5a);

    let baseEngineForce = 9000;
    let maxEngineForce = 9000;
    const brakeForce = 40;
    const maxSteerVal = 0.7;
    const VISUAL_Y_OFFSET = -0.9;
    const initialCarPosition = new CANNON.Vec3(-3320, 1, -20);
    
    let staticBodies = [];
    let carMesh = null;
    let tireMeshPrototype = null;
    let flameMesh = null;
    let targetArrowMesh = null;

    let gltfLoader = null;
    let dracoLoader = null;

    const inputState = { 
        keyW: false, keyS: false, keyA: false, keyD: false, 
        keySpace: false, keyShift: false, keyR: false 
    };

    // UI Elements
    const speedEl = document.getElementById('hud-spd');
    const altitudeEl = document.getElementById('hud-alt');
    const headingEl = document.getElementById('hud-hdg');
    const rpmEl = document.getElementById('hud-rpm');
    const gearEl = document.getElementById('hud-gear');
    const throttleEl = document.getElementById('hud-throttle');
    const coinCountEl = document.getElementById('coin-count');
    const splashCoinCountEl = document.getElementById('splash-coin-count');
    const loadingStatusEl = document.getElementById('loading-status');
    const loadingProgressFillEl = document.getElementById('loading-progress-fill');
    const driftBonusEl = document.getElementById('drift-bonus');

    // ** Delivery Mode Elements **
    const deliveryHudEl = document.getElementById('delivery-hud');
    const missionStatusEl = document.getElementById('mission-status-text');
    const distanceEl = document.getElementById('delivery-distance-value');
    const timerEl = document.getElementById('delivery-timer-value');

    let engineForce = 0;
    let steeringValue = 0;

    // Coin Vars
    let coinProto = null;
    let coinMeshes = [];
    let coinBodies = [];
    const COIN_MIN = 50;
    const COIN_MAX = 100;

    // ** Delivery Mode Vars **
    let isDeliveryModeActive = false;
    let currentMission = { status: 'none', pickupPoint: null, deliveryTarget: null, timeStarted: 0, timeLimit: 0, pickupMesh: null, deliveryMesh: null };
    const MAX_MISSION_TIME = 120000; // 120 seconds
    const TARGET_RADIUS = 5;
    const deliveryLocations = [
        { name: "Downtown Towers", x: -2500, z: 2000 },
        { name: "Harbor Port", x: -500, z: -3500 },
        { name: "Industrial Zone", x: 2000, z: -2000 },
        { name: "Residential Suburb", x: 3500, z: 2500 },
        { name: "Airport Runway", x: -500, z: 4000 }
    ];

    // ** Police Mode Vars **
    let isPoliceModeActive = false;
    let policeSpawnTime = 0;
    let policeActive = false;
    let policeVehicle = null;
    let policeChassis = null;
    let policeMesh = null;
    let policeWheelMeshes = [];
    let policeLight = null;
    let policeSirenTimer = 0;
    const POLICE_DELAY = 10000; // 10 seconds
    let policeSiren = null;


    // =============================================================================
    // ** INTERACTION **
    // =============================================================================
    document.addEventListener('mousedown', (e) => {
        if(!audioCtx) initAudio();
        if (!isGameRunning) {
            isDragging = true;
            previousMouseX = e.clientX;
            document.body.style.cursor = 'grabbing';
            document.getElementById('splash').style.cursor = 'grabbing';
        }
    });

    document.addEventListener('mouseup', () => {
        isDragging = false;
        document.body.style.cursor = 'default';
        document.getElementById('splash').style.cursor = 'grab';
    });

    document.addEventListener('mousemove', (e) => {
        if (isDragging && !isGameRunning) {
            const deltaX = e.clientX - previousMouseX;
            splashCameraAngle -= deltaX * 0.005;
            previousMouseX = e.clientX;
        }
    });

    function setupMobileControls() {
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        if(isMobile) {
            document.getElementById('mobile-controls').style.display = 'block';
            document.getElementById('control-hints').style.display = 'none';

            const bindBtn = (id, key) => {
                const btn = document.getElementById(id);
                btn.addEventListener('touchstart', (e) => { 
                    e.preventDefault(); 
                    inputState[key] = true; 
                    if(!audioCtx) initAudio();
                });
                btn.addEventListener('touchend', (e) => { 
                    e.preventDefault(); 
                    inputState[key] = false; 
                });
            };

            bindBtn('btn-gas', 'keyW');
            bindBtn('btn-brake', 'keyS');
            bindBtn('btn-left', 'keyA');
            bindBtn('btn-right', 'keyD');
            
            document.getElementById('btn-respawn-mob').addEventListener('touchstart', (e)=>{ e.preventDefault(); respawnCar();});
            document.getElementById('btn-camera-mob').addEventListener('touchstart', (e)=>{ e.preventDefault(); toggleCamera();});

        }
    }

    function showMenuPage(pageId) {
        if(!audioCtx) initAudio();
        const page = document.getElementById(pageId);
        if (page) {
            document.getElementById('splash').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('splash').style.display = 'none';
                page.classList.add('active');
            }, 400);
        }
    }

    window.hideMenuPages = function() {
        document.querySelectorAll('.menu-page').forEach(page => page.classList.remove('active'));
        document.getElementById('splash').style.display = 'flex';
        setTimeout(() => {
            document.getElementById('splash').style.opacity = '1';
        }, 50);
    }
    
    // =============================================================================
    // ** THREE.JS CORE **
    // =============================================================================
    function initThree() {
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(daySkyColor, 100, 800);
        
        // Chase Camera (Follow)
        const aspect = window.innerWidth / window.innerHeight;
        cameraChase = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
        cameraChase.position.set(0, 10, -20);
        cameraChase.lookAt(0, 0, 0);

        // Cockpit Camera (First-Person)
        cameraCockpit = new THREE.PerspectiveCamera(90, aspect, 0.1, 1000);
        cameraCockpit.position.set(0, 1.5, 0); // Relative to car, will be parented
        
        currentCamera = cameraChase;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(daySkyColor);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
    }

    function initCameraAndLights() {
        scene.add(new THREE.AmbientLight(0x444444));
        
        const hemiLight = new THREE.HemisphereLight(dayHemiSky, dayHemiGround, 0.6);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(-100, 300, 100);
        dirLight.castShadow = true;
        
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 1000;
        dirLight.shadow.camera.left = -200;
        dirLight.shadow.camera.right = 200;
        dirLight.shadow.camera.top = 200;
        dirLight.shadow.camera.bottom = -200;
        
        scene.add(dirLight);

        // Splash screen camera animation setup
        const splashCamera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 500);
        const splashCar = new THREE.Group(); 
        const splashCarGeo = new THREE.BoxGeometry(2,1,4);
        const splashCarMat = new THREE.MeshStandardMaterial({color: 0x00FFFF});
        const splashCarMesh = new THREE.Mesh(splashCarGeo, splashCarMat);
        splashCar.add(splashCarMesh);

        // Create a simple splash scene for the menu
        const splashScene = new THREE.Scene();
        splashScene.background = new THREE.Color(0x000000);
        splashScene.fog = new THREE.Fog(0x000000, 100, 400);
        splashScene.add(new THREE.AmbientLight(0x444444));
        const splashLight = new THREE.DirectionalLight(0x00FFFF, 1.0);
        splashLight.position.set(100, 100, 100);
        splashScene.add(splashLight);
        splashScene.add(splashCar);
        
        splashCar.position.set(-25, 0, 0);
        splashCar.rotation.y = Math.PI / 4;

        function animateSplash() {
            if (isGameRunning) return;
            requestAnimationFrame(animateSplash);
            
            // Camera orbit
            const radius = 50;
            splashCamera.position.x = Math.sin(splashCameraAngle) * radius;
            splashCamera.position.z = Math.cos(splashCameraAngle) * radius;
            splashCamera.position.y = 10;
            splashCamera.lookAt(splashCar.position);
            
            // Render the splash scene
            renderer.render(splashScene, splashCamera);
        }

        // Only start the splash animation if the main game hasn't started
        if (document.getElementById('splash').style.display !== 'none') {
            animateSplash();
        }
    }

    function initCannon() {
        world = new CANNON.World();
        world.gravity.set(0, -9.82, 0); 
        world.broadphase = new CANNON.SAPBroadphase(world);
        world.solver.iterations = 7;
        world.defaultContactMaterial.friction = 0.5;
        world.defaultContactMaterial.restitution = 0.2;
    }

    function initGround() {
        // Create a grid texture for the ground
        const textureLoader = new THREE.TextureLoader();
        const gridTexture = textureLoader.load('grid.jpg');
        gridTexture.wrapS = THREE.RepeatWrapping;
        gridTexture.wrapT = THREE.RepeatWrapping;
        gridTexture.repeat.set(100, 100);

        const groundMaterial = new THREE.MeshStandardMaterial({ 
            map: gridTexture, 
            color: 0x222222 
        });

        // Large ground plane
        const groundGeometry = new THREE.PlaneGeometry(10000, 10000, 1, 1);
        const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);

        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({ mass: 0, shape: groundShape });
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        world.addBody(groundBody);

        // Building blocks for the city
        const citySize = 5000;
        const numBlocks = 1500;
        for (let i = 0; i < numBlocks; i++) {
            const sizeX = Math.random() * 50 + 10;
            const sizeY = Math.random() * 50 + 5;
            const sizeZ = Math.random() * 50 + 10;
            const posX = (Math.random() - 0.5) * citySize * 2;
            const posZ = (Math.random() - 0.5) * citySize * 2;
            
            const boxGeo = new THREE.BoxGeometry(sizeX, sizeY, sizeZ);
            const color = new THREE.Color(Math.random() * 0.5 + 0.3, Math.random() * 0.5 + 0.3, Math.random() * 0.5 + 0.3);
            const boxMat = new THREE.MeshStandardMaterial({ color: color, metalness: 0.1, roughness: 0.9 });
            const boxMesh = new THREE.Mesh(boxGeo, boxMat);

            boxMesh.position.set(posX, sizeY / 2, posZ);
            boxMesh.castShadow = true;
            boxMesh.receiveShadow = true;
            scene.add(boxMesh);

            // Add CANNON physics body (initially not in the world to optimize)
            const boxShape = new CANNON.Box(new CANNON.Vec3(sizeX / 2, sizeY / 2, sizeZ / 2));
            const boxBody = new CANNON.Body({ mass: 0, shape: boxShape, position: new CANNON.Vec3(posX, sizeY / 2, posZ) });
            
            staticBodies.push({ 
                body: boxBody, 
                center: new THREE.Vector3(posX, sizeY / 2, posZ), 
                radius: Math.sqrt(sizeX*sizeX + sizeZ*sizeZ) / 2, 
                added: false 
            });
            // world.addBody(boxBody); // Add later when near the car
        }
    }

    function initVehicle() {
        const chassisShape = new CANNON.Box(new CANNON.Vec3(1, 0.5, 2));
        chassisBody = new CANNON.Body({ 
            mass: 2500, 
            shape: chassisShape, 
            position: initialCarPosition.clone() 
        });
        chassisBody.angularDamping = 0.9;
        chassisBody.linearDamping = 0.05;
        world.addBody(chassisBody);

        vehicle = new CANNON.RaycastVehicle({
            chassisBody: chassisBody,
            indexRightAxis: 0,
            indexUpAxis: 1,
            indexForwardAxis: 2
        });

        const axleWidth = 1.0;
        const wheelBase = 1.5;

        function makeWheelOptions(x,y,z) {
            // 检查 z 坐标，z < 0 表示后轮（根据下面的 vehicle.addWheel 调用可知）
            const isRear = z < 0; 
            return {
                radius: 0.5,
                directionLocal: new CANNON.Vec3(0, -1, 0),
                // **修改点 1：后轮悬挂调硬 (200) 以减轻后仰**
                suspensionStiffness: isRear ? 200 : 150, 
                suspensionRestLength: 0.3,
                frictionSlip: 4.0, 
                dampingRelaxation: 8.0, 
                dampingCompression: 10.0, 
                maxSuspensionForce: 100000, 
                rollInfluence: 0.05, 
                maxSuspensionTravel: 0.3,
                customSlidingRotationalSpeed: -30, 
                useCustomSlidingRotationalSpeed: true,
                axleLocal: new CANNON.Vec3(1, 0, 0),
                chassisConnectionPointLocal: new CANNON.Vec3(x, -0.3, z)
            };
        }

        vehicle.addWheel(makeWheelOptions(-axleWidth, 0, wheelBase)); // Front Left (0)
        vehicle.addWheel(makeWheelOptions( axleWidth, 0, wheelBase)); // Front Right (1)
        vehicle.addWheel(makeWheelOptions(-axleWidth, 0, -wheelBase)); // Back Left (2)
        vehicle.addWheel(makeWheelOptions( axleWidth, 0, -wheelBase)); // Back Right (3)

        vehicle.addToWorld(world);
        
        // Setup wheel meshes
        wheelMeshes = [];
        const wheelGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.2, 32);
        wheelGeo.rotateZ(Math.PI / 2);
        const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });

        for (let i = 0; i < vehicle.wheelInfos.length; i++) {
            let m;
            if (tireMeshPrototype) {
                m = tireMeshPrototype.clone();
            } else {
                m = new THREE.Mesh(wheelGeo, wheelMat);
            }
            m.castShadow = true;
            m.receiveShadow = true;
            scene.add(m);
            wheelMeshes.push(m);
        }

        // Parent the cockpit camera to the car mesh (or chassis body)
        // Position it relative to the visual car mesh
        cameraCockpit.position.set(0, 0.5, -0.2); // Adjusted for visual offset and placement
        carMesh.add(cameraCockpit);
    }

    function initLoaders() {
        const loadingManager = new THREE.LoadingManager();
        loadingManager.onProgress = (url, itemsLoaded, itemsTotal) => {
            const progress = (itemsLoaded / itemsTotal) * 100;
            loadingProgressFillEl.style.width = `${progress}%`;
            loadingStatusEl.textContent = `(${progress.toFixed(0)}%) Loading: ${url.substring(url.lastIndexOf('/') + 1)}`;
        };

        loadingManager.onLoad = () => {
            document.getElementById('loading-screen').style.opacity = '0';
            document.getElementById('loading-screen').style.pointerEvents = 'none';
            document.getElementById('splash').style.display = 'flex';
            setTimeout(() => {
                document.getElementById('loading-screen').style.display = 'none';
            }, 500);
            
            initVehicle(); // Initialize vehicle after models are loaded
            if(isPoliceModeActive) createPoliceVehicle(); // Initialize police components early
            requestAnimationFrame(animate);
        };

        dracoLoader = new THREE.DRACOLoader();
        dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
        gltfLoader = new THREE.GLTFLoader(loadingManager);
        gltfLoader.setDRACOLoader(dracoLoader);
    }

    function loadCarModel() {
        gltfLoader.load('car1.glb', (gltf) => {
            carMesh = gltf.scene;
            const SCALE_FACTOR = 104.7; // Scale to match physics body size (2x1x4)
            carMesh.scale.set(SCALE_FACTOR, SCALE_FACTOR, SCALE_FACTOR);
            carMesh.rotation.y = Math.PI;
            carMesh.traverse((node) => {
                if (node.isMesh) node.castShadow = true;
            });
            scene.add(carMesh);

            const flameGeometry = new THREE.ConeGeometry(0.3, 1, 16);
            const flameMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.75 });
            flameMesh = new THREE.Mesh(flameGeometry, flameMaterial);
            flameMesh.rotation.x = -Math.PI / 2;
            flameMesh.position.set(0, 0, 2.5);
            flameMesh.visible = false;
            carMesh.add(flameMesh);

        }, undefined, (e) => { 
            console.warn("Using placeholder car."); 
            const boxGeo = new THREE.BoxGeometry(2, 0.5, 4);
            const boxMat = new THREE.MeshStandardMaterial({ color: 0x00FFFF });
            carMesh = new THREE.Mesh(boxGeo, boxMat);
            carMesh.castShadow = true;
            scene.add(carMesh);
        });
    }

    function loadTireModel() {
        // Load the tire model once to clone for all wheels
        gltfLoader.load('tire.glb', (gltf) => {
            tireMeshPrototype = gltf.scene;
            const SCALE_FACTOR = 100;
            tireMeshPrototype.scale.set(SCALE_FACTOR, SCALE_FACTOR, SCALE_FACTOR);
            tireMeshPrototype.rotation.y = Math.PI/2;
            tireMeshPrototype.traverse((node) => {
                if (node.isMesh) node.castShadow = true;
            });
        }, undefined, (e) => { 
            console.warn("Using placeholder tires."); 
        });
    }
    
    function loadCity() {
        // Placeholder for future city loading (e.g., roads, complex buildings)
    }

    function loadCoinPrototype(callback) {
        const coinLoader = new THREE.GLTFLoader();
        coinLoader.load('gold_coin.glb', (gltf) => {
            coinProto = gltf.scene;
            coinProto.traverse(node => {
                if (node.isMesh) node.castShadow = true;
            });
            if (callback) callback();
        }, undefined, (err) => { 
            console.warn('gold_coin.glb fallback');
            const geo = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 16);
            const mat = new THREE.MeshBasicMaterial({color: 0xFFD700});
            coinProto = new THREE.Mesh(geo, mat);
            if (callback) callback();
        });
    }

    function loadArrowModel() {
        gltfLoader.load('arrow.glb', (gltf) => {
            targetArrowMesh = gltf.scene;
            targetArrowMesh.scale.set(1.0, 1.0, 1.0);
            targetArrowMesh.traverse((node) => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.material = new THREE.MeshBasicMaterial({ 
                        color: 0xFF0000, 
                        transparent: true, 
                        opacity: 0.8,
                        depthTest: false // Renders over everything
                    });
                }
            });
            targetArrowMesh.visible = false;
            scene.add(targetArrowMesh);
            targetArrowMesh.userData.pickupColor = new THREE.Color(0x00FFFF);
            targetArrowMesh.userData.deliveryColor = new THREE.Color(0x00FF00);

        }, undefined, (e) => { 
            console.warn("Using placeholder arrow."); 
            const geo = new THREE.ConeGeometry(0.5, 1.5, 8);
            const mat = new THREE.MeshBasicMaterial({ color: 0xFF0000, transparent: true, opacity: 0.8, depthTest: false });
            targetArrowMesh = new THREE.Mesh(geo, mat);
            targetArrowMesh.rotation.x = -Math.PI / 2;
            targetArrowMesh.position.y = 2; 
            targetArrowMesh.visible = false;
            scene.add(targetArrowMesh);
            targetArrowMesh.userData.pickupColor = new THREE.Color(0x00FFFF);
            targetArrowMesh.userData.deliveryColor = new THREE.Color(0x00FF00);
        });
    }
    
    // =============================================================================
    // ** GAME LOGIC - COINS & PICKUPS **
    // =============================================================================
    function spawnCoins(count) {
        if (!coinProto) return;
        const citySize = 5000;
        for (let i = 0; i < count; i++) {
            const posX = (Math.random() - 0.5) * citySize * 2;
            const posZ = (Math.random() - 0.5) * citySize * 2;
            
            const coinMesh = coinProto.clone();
            coinMesh.position.set(posX, 1.0, posZ);
            coinMesh.userData.collected = false;
            scene.add(coinMesh);
            coinMeshes.push(coinMesh);

            const coinShape = new CANNON.Cylinder(0.5, 0.5, 0.1, 16);
            const coinBody = new CANNON.Body({ mass: 0, position: new CANNON.Vec3(posX, 1.0, posZ), shape: coinShape });
            coinBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            coinBody.collisionResponse = 0; // Does not affect car physics
            world.addBody(coinBody);
            coinBodies.push(coinBody);

            coinBody.addEventListener('collide', handleCoinCollision);
        }
    }

    function handleCoinCollision(e) {
        if (!isGameRunning) return;
        const bodyA = e.body;
        const bodyB = e.target;
        
        // Ensure collision is with the chassisBody and a coin
        if ((bodyA === chassisBody || bodyB === chassisBody)) {
            const coinBody = (bodyA === chassisBody) ? bodyB : bodyA;
            const index = coinBodies.indexOf(coinBody);
            
            if (index !== -1) {
                const coinMesh = coinMeshes[index];
                if (coinMesh && !coinMesh.userData.collected) {
                    collectCoin(index);
                }
            }
        }
    }

    function collectCoin(index) {
        const coinBody = coinBodies[index];
        const coinMesh = coinMeshes[index];

        coinMesh.userData.collected = true;
        
        world.removeBody(coinBody);
        scene.remove(coinMesh);
        
        // Remove from arrays and handle index shifts
        coinBodies.splice(index, 1);
        coinMeshes.splice(index, 1);
        
        // Give player coin
        const bonus = gameData.upgrades.gold ? 2 : 1;
        gameData.coins += bonus;
        saveGameData();
        playCoinSound();
    }
    
    // =============================================================================
    // ** GAME LOGIC - DELIVERY MODE **
    // =============================================================================

    window.startDeliveryMode = function() {
        if (!chassisBody) {
            alert("Loading assets...");
            return;
        }
        if (!isGameRunning) enterGame();
        
        isPoliceModeActive = false;
        if(policeActive) despawnPolice();

        isDeliveryModeActive = true;
        deliveryHudEl.style.display = 'block';
        document.getElementById('police-hud').style.display = 'none';

        if (currentMission.status === 'none' || currentMission.status === 'completed') {
            startNewMission();
        }
        respawnCar();
    }

    function startNewMission() {
        // Clean up previous mission if any
        if (currentMission.pickupPoint) world.removeBody(currentMission.pickupPoint);
        if (currentMission.deliveryTarget) world.removeBody(currentMission.deliveryTarget);
        if (currentMission.pickupMesh) scene.remove(currentMission.pickupMesh);
        if (currentMission.deliveryMesh) scene.remove(currentMission.deliveryMesh);

        // Select two distinct random locations
        let pickupData, deliveryData;
        const numLocations = deliveryLocations.length;
        let pIndex = Math.floor(Math.random() * numLocations);
        let dIndex;
        do {
            dIndex = Math.floor(Math.random() * numLocations);
        } while (dIndex === pIndex);
        
        pickupData = deliveryLocations[pIndex];
        deliveryData = deliveryLocations[dIndex];

        const pickupPos = new CANNON.Vec3(pickupData.x, 1, pickupData.z);
        const deliveryPos = new CANNON.Vec3(deliveryData.x, 1, deliveryData.z);

        const targetShape = new CANNON.Cylinder(TARGET_RADIUS, TARGET_RADIUS, 1, 16);
        
        const pickupBody = new CANNON.Body({ mass: 0, position: pickupPos, shape: targetShape });
        pickupBody.collisionResponse = 0;
        world.addBody(pickupBody);

        const deliveryBody = new CANNON.Body({ mass: 0, position: deliveryPos, shape: targetShape });
        deliveryBody.collisionResponse = 0;
        world.addBody(deliveryBody);
        
        const pickupMesh = createTargetMesh(0x00FFFF);
        pickupMesh.position.copy(pickupPos);
        scene.add(pickupMesh);
        
        const deliveryMesh = createTargetMesh(0x00FF00);
        deliveryMesh.position.copy(deliveryPos);
        deliveryMesh.visible = false;
        scene.add(deliveryMesh);

        currentMission = {
            status: 'pickup',
            pickupPoint: pickupBody,
            deliveryTarget: deliveryBody,
            timeStarted: performance.now(),
            timeLimit: MAX_MISSION_TIME,
            pickupMesh: pickupMesh,
            deliveryMesh: deliveryMesh,
            pickupName: pickupData.name,
            deliveryName: deliveryData.name,
        };
        missionStatusEl.textContent = `MISSION: Go to ${pickupData.name} for Pickup`;
        missionStatusEl.style.color = '#00FFFF';

        chassisBody.addEventListener('collide', handleMissionCollision);
    }

    function createTargetMesh(color) {
        const geometry = new THREE.CylinderGeometry(TARGET_RADIUS / 2, TARGET_RADIUS / 2, TARGET_RADIUS, 16);
        const material = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.7 });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.y += TARGET_RADIUS / 2;
        return mesh;
    }

    function handleMissionCollision(e) {
        if (!isDeliveryModeActive || currentMission.status === 'none' || currentMission.status === 'completed') return;
        
        const otherBody = (e.body === chassisBody) ? e.target : e.body;

        if (currentMission.status === 'pickup' && otherBody === currentMission.pickupPoint) {
            currentMission.status = 'delivering';
            missionStatusEl.textContent = `MISSION: Deliver cargo to ${currentMission.deliveryName}`;
            missionStatusEl.style.color = '#00FF00';
            
            // Swap visual targets
            currentMission.pickupMesh.visible = false;
            currentMission.deliveryMesh.visible = true;

        } else if (currentMission.status === 'delivering' && otherBody === currentMission.deliveryTarget) {
            currentMission.status = 'completed';
            missionStatusEl.textContent = "MISSION COMPLETE! (+1 Gold)";
            missionStatusEl.style.color = '#FFD700';
            
            // Clean up
            world.removeBody(currentMission.pickupPoint);
            world.removeBody(currentMission.deliveryTarget);
            scene.remove(currentMission.pickupMesh);
            scene.remove(currentMission.deliveryMesh);

            // Reward
            gameData.coins += 1;
            saveGameData();
            playCoinSound();

            // Start next mission after a delay
            setTimeout(startNewMission, 3000);
        }
    }

    function updateDeliveryMode() {
        if (currentMission.status === 'none' || currentMission.status === 'completed') {
            timerEl.textContent = '--:--';
            distanceEl.textContent = '0';
            return;
        }

        const elapsed = performance.now() - currentMission.timeStarted;
        const timeLeft = Math.max(0, currentMission.timeLimit - elapsed);
        
        const seconds = Math.floor(timeLeft / 1000);
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        
        timerEl.textContent = `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        
        if (timeLeft <= 0) {
            // Mission Failed
            currentMission.status = 'failed';
            missionStatusEl.textContent = "MISSION FAILED! Time's Up.";
            missionStatusEl.style.color = '#FF0000';
            
            // Clean up
            world.removeBody(currentMission.pickupPoint);
            world.removeBody(currentMission.deliveryTarget);
            scene.remove(currentMission.pickupMesh);
            scene.remove(currentMission.deliveryMesh);
            
            // Start next mission after a delay
            setTimeout(startNewMission, 3000);
            return;
        }
        
        // Update distance
        let targetBody = null;
        if (currentMission.status === 'pickup') targetBody = currentMission.pickupPoint;
        else if (currentMission.status === 'delivering') targetBody = currentMission.deliveryTarget;

        if (targetBody) {
            const dist = chassisBody.position.distanceTo(targetBody.position);
            distanceEl.textContent = dist.toFixed(0);
        } else {
            distanceEl.textContent = '0';
        }
    }

    // =============================================================================
    // ** POLICE MODE LOGIC (NEW) **
    // =============================================================================
    window.startPoliceMode = function() {
        if (!chassisBody) {
            alert("Loading assets...");
            return;
        }
        if (!isGameRunning) enterGame();
        
        isDeliveryModeActive = false;
        if(deliveryHudEl) deliveryHudEl.style.display = 'none';
        
        isPoliceModeActive = true;
        policeActive = false;
        policeSpawnTime = performance.now() + POLICE_DELAY;
        document.getElementById('police-hud').style.display = 'block';
        document.getElementById('police-alert').innerText = "POLICE INBOUND";
        document.getElementById('police-alert').style.color = "#FFD700"; // Warn color
        
        respawnCar();
    }
    
    function createPoliceVehicle() {
        if(policeChassis) return; // Already created
        
        const chassisShape = new CANNON.Box(new CANNON.Vec3(1, 0.5, 2));
        policeChassis = new CANNON.Body({ 
            mass: 3000, // Heavier than player
            shape: chassisShape 
        });
        policeChassis.angularDamping = 0.9;
        policeChassis.linearDamping = 0.05;

        policeVehicle = new CANNON.RaycastVehicle({
            chassisBody: policeChassis,
            indexRightAxis: 0,
            indexUpAxis: 1,
            indexForwardAxis: 2
        });
        
        const axleWidth = 1.0;
        const wheelBase = 1.5;

        // Uses default wheel options for police (no anti-squat bias for simplicity)
        function makeWheelOptions(x,y,z) {
            return {
                radius: 0.5,
                directionLocal: new CANNON.Vec3(0, -1, 0),
                suspensionStiffness: 150, 
                suspensionRestLength: 0.3,
                frictionSlip: 4.0, 
                dampingRelaxation: 8.0, 
                dampingCompression: 10.0, 
                maxSuspensionForce: 100000, 
                rollInfluence: 0.05, 
                axleLocal: new CANNON.Vec3(1, 0, 0),
                chassisConnectionPointLocal: new CANNON.Vec3(x, -0.3, z)
            };
        }

        policeVehicle.addWheel(makeWheelOptions(-axleWidth, 0, wheelBase));
        policeVehicle.addWheel(makeWheelOptions( axleWidth, 0, wheelBase));
        policeVehicle.addWheel(makeWheelOptions(-axleWidth, 0, -wheelBase));
        policeVehicle.addWheel(makeWheelOptions( axleWidth, 0, -wheelBase));
        
        policeVehicle.addToWorld(world);
        
        // --- VISUALS ---
        const SCALE_FACTOR = 104.7;

        if(carMesh) { // Use car model as police car for simplicity, just change color/lights
            policeMesh = carMesh.clone();
            policeMesh.scale.set(SCALE_FACTOR, SCALE_FACTOR, SCALE_FACTOR);
            policeMesh.rotation.y = Math.PI;

            // Simple recoloring for a 'police look'
            policeMesh.traverse((node) => {
                if (node.isMesh) {
                    node.castShadow = true;
                    // Change material to a dark police color (e.g., black or dark blue)
                    node.material = new THREE.MeshStandardMaterial({
                        color: 0x000044, // Dark blue
                        metalness: 0.5,
                        roughness: 0.5
                    });
                }
            });
            scene.add(policeMesh);

            // Light Bar
            const lightBarGeo = new THREE.BoxGeometry(1.5 * SCALE_FACTOR, 0.1 * SCALE_FACTOR, 0.4 * SCALE_FACTOR);
            const lightBarMat = new THREE.MeshBasicMaterial({ color: 0x333333 });
            const lightBar = new THREE.Mesh(lightBarGeo, lightBarMat);
            lightBar.position.y = 0.5 * SCALE_FACTOR; // Top of the scaled model.

            // Red and Blue Lights
            const lightGeo = new THREE.BoxGeometry(0.3 * SCALE_FACTOR, 0.11 * SCALE_FACTOR, 0.21 * SCALE_FACTOR);
            const redMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const redLight = new THREE.Mesh(lightGeo, redMat);
            redLight.position.x = -0.0035; // X position, close to center

            const blueMat = new THREE.MeshBasicMaterial({ color: 0x0000ff });
            const blueLight = new THREE.Mesh(lightGeo, blueMat);
            blueLight.position.x = 0.0035;
            
            lightBar.add(redLight);
            lightBar.add(blueLight);
            policeMesh.add(lightBar);
            
            policeLight = { red: redLight, blue: blueLight, state: 0 };
            
            scene.add(policeMesh);

        } else {
            // Fallback box (If model failed to load)
            const boxGeo = new THREE.BoxGeometry(2,1,4);
            const boxMat = new THREE.MeshBasicMaterial({color:0x0000FF});
            policeMesh = new THREE.Mesh(boxGeo, boxMat);
            scene.add(policeMesh);
        }

        // Wheels
        policeWheelMeshes = [];
        const cylGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.2, 32);
        cylGeo.rotateZ(Math.PI/2);
        const wheelMat = new THREE.MeshStandardMaterial({color:0x111111});
        for(let i=0; i<4; i++){
            let m;
            if(tireMeshPrototype) {
                m = tireMeshPrototype.clone();
            } else {
                m = new THREE.Mesh(cylGeo, wheelMat);
            }
            scene.add(m);
            policeWheelMeshes.push(m);
        }

        // Set to hidden initially until spawn
        policeMesh.visible = false;
        policeWheelMeshes.forEach(m => m.visible = false);
    }
    
    function spawnPolice() {
        if(!policeChassis) createPoliceVehicle();
        
        // 获取玩家当前位置和朝向
        const playerPos = chassisBody.position;
        const playerQuat = chassisBody.quaternion;

        // 计算玩家后方的一个点 (距离100m)
        const forwardVector = new THREE.Vector3(0,0,1).applyQuaternion(new THREE.Quaternion(playerQuat.x, playerQuat.y, playerQuat.z, playerQuat.w));
        const spawnDistance = 100;
        const spawnPos = new CANNON.Vec3(
            playerPos.x + forwardVector.x * spawnDistance, 
            playerPos.y + 1, // Spawn slightly above ground
            playerPos.z + forwardVector.z * spawnDistance
        );

        // 设置警车初始位置和方向 (与玩家初始方向一致)
        policeChassis.position.copy(spawnPos);
        policeChassis.quaternion.copy(playerQuat);
        policeChassis.velocity.set(0, 0, 0);
        policeChassis.angularVelocity.set(0, 0, 0);
        
        policeMesh.visible = true;
        policeWheelMeshes.forEach(m => m.visible = true);
        policeActive = true;
        
        document.getElementById('police-alert').innerText = "PURSUIT ACTIVE";
        document.getElementById('police-alert').style.color = "#FF0000";

        // Start siren sound
        if (!policeSiren) policeSiren = playSirenSound();
    }

    function despawnPolice() {
        if (policeActive) {
            policeActive = false;
            policeMesh.visible = false;
            policeWheelMeshes.forEach(m => m.visible = false);
            
            // Stop siren sound
            if (policeSiren && policeSiren.gain) {
                policeSiren.gain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.2);
                setTimeout(() => {
                    policeSiren.osc.stop();
                    policeSiren = null;
                }, 300);
            }
        }
    }

    function updatePoliceAI() {
        if (!policeActive || !policeVehicle || !chassisBody) return;

        const policePos = policeChassis.position;
        const playerPos = chassisBody.position;
        const policeSpeed = policeChassis.velocity.length() * 3.6; // KM/H
        
        // --- 1. 转向逻辑：预判、平滑、速度限制 ---
        const MAX_POLICE_FORCE = 20000;
        const PREDICT_TIME = 0.5; // 预判时间 (秒)
        const playerVelocity = chassisBody.velocity.clone();

        // 预测玩家未来位置，用于更精确的瞄准
        const predictedPlayerPos = new CANNON.Vec3(
            playerPos.x + playerVelocity.x * PREDICT_TIME,
            playerPos.y,
            playerPos.z + playerVelocity.z * PREDICT_TIME
        );

        const targetVec = new CANNON.Vec3(predictedPlayerPos.x - policePos.x, 0, predictedPlayerPos.z - policePos.z);
        
        // 获取警察当前朝向和目标朝向的角度差
        const policeQuat = new THREE.Quaternion(policeChassis.quaternion.x, policeChassis.quaternion.y, policeChassis.quaternion.z, policeChassis.quaternion.w);
        const forward = new THREE.Vector3(0,0,1).applyQuaternion(policeQuat);
        const targetThree = new THREE.Vector3(targetVec.x, 0, targetVec.z).normalize();
        
        let angle = forward.angleTo(targetThree);
        const cross = new THREE.Vector3().crossVectors(forward, targetThree);
        if(cross.y > 0) angle = -angle; // 确定转向方向 (+/-)

        // 基础转向值：与角度成比例
        let targetSteer = angle * 2.0;
        targetSteer = THREE.MathUtils.clamp(targetSteer, -maxSteerVal, maxSteerVal);

        // 平滑转向过渡 (Lerp)
        const LERP_RATE = 0.15; // 转向平滑率
        let currentSteer = policeVehicle.getSteeringValue(0);
        let steer = currentSteer + (targetSteer - currentSteer) * LERP_RATE;

        // 速度依赖的转向极限 (高速时限制最大转向角)
        const MAX_SPEED_TURN_LIMIT = 0.4; // 极限速度下的最大转向比率 (例如 maxSteerVal 的 40%)
        const MAX_TURN_SPEED = 180; // 高速定义的阈值 (KM/H)
        if(policeSpeed > 5) {
            const speedFactor = Math.min(1, policeSpeed / MAX_TURN_SPEED);
            const turnLimit = maxSteerVal * (1 - speedFactor * (1 - MAX_SPEED_TURN_LIMIT));
            steer = THREE.MathUtils.clamp(steer, -turnLimit, turnLimit);
        }


        // --- 2. 引擎力与刹车逻辑 ---
        let force = 0;
        let brakeForce = 0;
        const distance = policePos.distanceTo(playerPos);

        if (distance > 5) { // 玩家较远，加速追逐
            force = -MAX_POLICE_FORCE; // 向前
            if (Math.abs(angle) > Math.PI / 8) { // 如果角度太大，轻微刹车以辅助转向
                 brakeForce = MAX_POLICE_FORCE * 0.1;
            }
        } else { // 玩家很近，尝试碰撞/减速
            force = 0;
            brakeForce = MAX_POLICE_FORCE * 0.5; // 重刹车
        }

        // --- 3. 脱困与自救逻辑 (Backtrack/Reverse) ---
        if (policeSpeed < 2 && distance > 5 && performance.now() - policeSpawnTime > 5000) { 
             // 速度极慢，且未抓到玩家 (可能被卡住)，尝试倒车
            if (Math.abs(angle) < Math.PI / 4) { 
                // 朝向正确，尝试向前加速
                force = -MAX_POLICE_FORCE;
            } else {
                // 朝向错误，尝试倒车脱困
                force = MAX_POLICE_FORCE * 0.5;
            }
            brakeForce = 0;
        }
        
        // 4. 自恢复机制 (防止车辆翻倒)
        const up = new THREE.Vector3(0,1,0).applyQuaternion(policeQuat);
        if(up.y < 0.2) {
            policeChassis.position.y += 2; // 抬升
            policeChassis.quaternion.set(0,0,0,1); // 重置旋转
            policeChassis.velocity.set(0,0,0); // 清除速度
            policeChassis.angularVelocity.set(0,0,0); // 清除角速度
        }


        // --- 5. 应用控制 ---
        // 应用转向
        policeVehicle.setSteeringValue(steer, 0);
        policeVehicle.setSteeringValue(steer, 1);

        // 重置所有引擎力和刹车力
        policeVehicle.applyEngineForce(0, 0);
        policeVehicle.applyEngineForce(0, 1);
        policeVehicle.applyEngineForce(0, 2);
        policeVehicle.applyEngineForce(0, 3);
        policeVehicle.setBrake(0, 0);
        policeVehicle.setBrake(0, 1);
        policeVehicle.setBrake(0, 2);
        policeVehicle.setBrake(0, 3);

        // 应用计算出的引擎力和刹车力 (作用于所有轮子)
        policeVehicle.applyEngineForce(force, 0);
        policeVehicle.applyEngineForce(force, 1);
        policeVehicle.applyEngineForce(force, 2);
        policeVehicle.applyEngineForce(force, 3);

        policeVehicle.setBrake(brakeForce, 0);
        policeVehicle.setBrake(brakeForce, 1);
        policeVehicle.setBrake(brakeForce, 2);
        policeVehicle.setBrake(brakeForce, 3);

        // --- 6. 更新视觉效果 ---
        for(let i=0; i<policeVehicle.wheelInfos.length; i++){
            policeVehicle.updateWheelTransform(i);
            let t = policeVehicle.wheelInfos[i].worldTransform;
            if(policeWheelMeshes[i]) {
                policeWheelMeshes[i].position.copy(t.position);
                policeWheelMeshes[i].quaternion.copy(t.quaternion);
            }
        }
        if(policeMesh) {
            policeMesh.position.copy(policeChassis.position);
            policeMesh.quaternion.copy(policeChassis.quaternion);
            policeMesh.position.y += VISUAL_Y_OFFSET; // Apply visual offset
        }

        // Siren Light effect
        policeSirenTimer += 1/60;
        if(policeLight) {
            const timeFactor = Math.floor(policeSirenTimer * 10);
            if(timeFactor % 2 === 0) {
                policeLight.red.material.color.setHex(0xff0000);
                policeLight.blue.material.color.setHex(0x000033);
            } else {
                policeLight.red.material.color.setHex(0x330000);
                policeLight.blue.material.color.setHex(0x0000ff);
            }
        }

        // Busted check (distance < 5m and speed < 10 km/h)
        if(distance < 5 && chassisBody.velocity.length() * 3.6 < 10) {
            document.getElementById('busted-screen').style.display = 'flex';
            isGameRunning = false;
        }
    }


    // =============================================================================
    // ** CONTROLS AND UPDATE **
    // =============================================================================
    window.addEventListener('keydown', (event) => {
        if (!isGameRunning) return;
        if(!audioCtx) initAudio();
        
        const k = event.key.toLowerCase();
        if(k==='w' || k==='arrowup') inputState.keyW = true;
        if(k==='s' || k==='arrowdown') inputState.keyS = true;
        if(k==='a' || k==='arrowleft') inputState.keyA = true;
        if(k==='d' || k==='arrowright') inputState.keyD = true;
        if(k===' ') inputState.keySpace = true;
        if(k==='shift') inputState.keyShift = true;
        
        if(k==='r') {
            respawnCar();
            inputState.keyR = true;
        }
        if(k==='v') toggleCamera();
    });

    window.addEventListener('keyup', (event) => {
        if (!isGameRunning) return;
        const k = event.key.toLowerCase();
        if(k==='w' || k==='arrowup') inputState.keyW = false;
        if(k==='s' || k==='arrowdown') inputState.keyS = false;
        if(k==='a' || k==='arrowleft') inputState.keyA = false;
        if(k==='d' || k==='arrowright') inputState.keyD = false;
        if(k===' ') inputState.keySpace = false;
        if(k==='shift') inputState.keyShift = false;
        if(k==='r') inputState.keyR = false;
    });

    function toggleCamera() {
        if (!carMesh) return;
        if (cameraMode === 'chase') {
            cameraMode = 'cockpit';
            currentCamera = cameraCockpit;
        } else {
            cameraMode = 'chase';
            currentCamera = cameraChase;
        }
    }
    
    function respawnCar() {
        // Reset position and rotation
        chassisBody.position.copy(initialCarPosition);
        chassisBody.quaternion.set(0, 0, 0, 1);
        chassisBody.velocity.set(0, 0, 0);
        chassisBody.angularVelocity.set(0, 0, 0);
        
        // Reset controls
        engineForce = 0;
        steeringValue = 0;
        
        // Optionally, reset missions/police when respawn is forced
        if(isDeliveryModeActive) {
            if(currentMission.status !== 'none' && currentMission.status !== 'completed') {
                // Fail current mission if respawning mid-delivery
                currentMission.status = 'failed';
                missionStatusEl.textContent = "MISSION FAILED! Respawned.";
                missionStatusEl.style.color = '#FF0000';
                
                world.removeBody(currentMission.pickupPoint);
                world.removeBody(currentMission.deliveryTarget);
                scene.remove(currentMission.pickupMesh);
                scene.remove(currentMission.deliveryMesh);
                setTimeout(startNewMission, 3000);
            }
        }
        if(isPoliceModeActive) {
            // Re-arm police spawn timer
            despawnPolice();
            policeActive = false;
            policeSpawnTime = performance.now() + POLICE_DELAY;
            document.getElementById('police-alert').innerText = "POLICE INBOUND";
            document.getElementById('police-alert').style.color = "#FFD700";
        }
    }

    function applyUpgrades() {
        // Apply Engine Upgrade
        if (gameData.upgrades.engine > 0) {
            maxEngineForce = baseEngineForce * 1.5; // 50% more power
        } else {
            maxEngineForce = baseEngineForce;
        }
        
        // Apply Paint Upgrade
        if (carMesh && carMesh.isMesh) { // For placeholder car
            if (gameData.upgrades.paint > 0) {
                carMesh.material.color.setHex(0xFF0055);
            } else {
                carMesh.material.color.setHex(0x00FFFF);
            }
        } else if (carMesh && carMesh.children) { // For GLTF model
            carMesh.traverse((node) => {
                if (node.isMesh) {
                    if (gameData.upgrades.paint > 0) {
                        node.material.color.setHex(0xFF0055); // Set to cyberpunk red
                    } else {
                        node.material.color.setHex(0xAAAAAA); // Default gray/white
                    }
                }
            });
        }
    }


    function updateControls() {
        // Reset values
        engineForce = 0;
        steeringValue = 0;
        let brake = 0;
        
        // Car vectors for drift calculation
        const velocityVector = new THREE.Vector3().copy(chassisBody.velocity);
        const q = chassisBody.quaternion;
        const forwardVector = new THREE.Vector3(0, 0, -1).applyQuaternion(new THREE.Quaternion(q.x, q.y, q.z, q.w));
        const sidewaysVector = new THREE.Vector3(-1, 0, 0).applyQuaternion(new THREE.Quaternion(q.x, q.y, q.z, q.w));
        
        const speed = chassisBody.velocity.length();
        const forwardSpeed = velocityVector.dot(forwardVector);

        // Drift check
        const slide = Math.abs(velocityVector.dot(sidewaysVector));
        const driftThreshold = 4;
        let isDrifting = false;
        
        if (inputState.keySpace && speed > 5) { // Drifting is easier when braking
            isDrifting = true;
        } else if (slide > driftThreshold && speed > 10) {
             isDrifting = true;
        }

        if (isDrifting) {
            driftBonusEl.style.display = 'block';
            driftBonusEl.textContent = `DRIFT BONUS! +${Math.round(slide*5)}`;
            // Increase friction slip on the front wheels slightly to allow drifting
            vehicle.wheelInfos[0].frictionSlip = 1.0;
            vehicle.wheelInfos[1].frictionSlip = 1.0;
            // Lower rear wheel friction for easier slide
            vehicle.wheelInfos[2].frictionSlip = 0.5;
            vehicle.wheelInfos[3].frictionSlip = 0.5;

            // Simple drift coin bonus (can be improved)
            if (Math.random() < 0.05) {
                const bonus = gameData.upgrades.gold ? 2 : 1;
                gameData.coins += (1 * bonus);
                saveGameData();
            }

        } else {
            isDrifting = false;
            driftBonusEl.style.display = 'none';
            // Restore normal friction
            vehicle.wheelInfos[0].frictionSlip = 4.0;
            vehicle.wheelInfos[1].frictionSlip = 4.0;
            vehicle.wheelInfos[2].frictionSlip = 4.0;
            vehicle.wheelInfos[3].frictionSlip = 4.0;
        }
        
        const isMovingForward = velocityVector.dot(forwardVector) > 0.5;
        const isMovingBackward = velocityVector.dot(forwardVector) < -0.5;
        
        if (inputState.keyA) steeringValue = maxSteerVal;
        else if (inputState.keyD) steeringValue = -maxSteerVal;

        if (inputState.keyW) {
            if (isMovingBackward) brake = maxEngineForce * 0.5;
            else { 
                engineForce = -maxEngineForce; 
                gearEl.textContent = 'D'; 
            }
        } else if (inputState.keyS) {
            if (isMovingForward) brake = maxEngineForce * 0.5;
            else { 
                engineForce = maxEngineForce * 0.5; 
                gearEl.textContent = 'R'; 
            }
        } else if (!inputState.keySpace) {
            gearEl.textContent = (forwardSpeed < 1) ? 'P' : 'N';
        }
        
        if (inputState.keyShift && engineForce !== 0) {
            engineForce *= 2.5;
            if (flameMesh) flameMesh.visible = true;
        } else {
            if (flameMesh) flameMesh.visible = false;
        }

        vehicle.setSteeringValue(steeringValue, 0);
        vehicle.setSteeringValue(steeringValue, 1);
        
        // **修改点 2：四驱动力分配：将大部分动力压到前轮 (90%) 以减轻后仰**
        const frontBias = 0.9; // 前轮动力比例 (90%)
        const rearBias = 0.1;  // 后轮动力比例 (10%)

        vehicle.applyEngineForce(engineForce * frontBias, 0); // 前左轮
        vehicle.applyEngineForce(engineForce * frontBias, 1); // 前右轮

        vehicle.applyEngineForce(engineForce * rearBias, 2);  // 后左轮
        vehicle.applyEngineForce(engineForce * rearBias, 3);  // 后右轮
        
        let finalBrakeRL = brake, finalBrakeRR = brake;
        if (inputState.keySpace) {
            finalBrakeRL = maxEngineForce * 0.8; finalBrakeRR = maxEngineForce * 0.8;
            gearEl.textContent = 'E';
        } else if (brake === 0) {
            vehicle.setBrake(0, 0); vehicle.setBrake(0, 1); vehicle.setBrake(0, 2); vehicle.setBrake(0, 3);
        }
        
        vehicle.setBrake(brake, 0); vehicle.setBrake(brake, 1);
        vehicle.setBrake(finalBrakeRL, 2); vehicle.setBrake(finalBrakeRR, 3);

        // Update HUD
        const displaySpeed = Math.abs(chassisBody.velocity.length() * 3.6); // m/s to km/h
        speedEl.textContent = displaySpeed.toFixed(0);
        altitudeEl.textContent = chassisBody.position.y.toFixed(0);

        const euler = new THREE.Euler().setFromQuaternion(new THREE.Quaternion(q.x, q.y, q.z, q.w), 'YXZ');
        let heading = (euler.y * 180 / Math.PI) % 360;
        if(heading < 0) heading += 360;
        headingEl.textContent = heading.toFixed(0).padStart(3, '0');

        const rpm = Math.min(99, Math.abs(displaySpeed / 2));
        rpmEl.textContent = rpm.toFixed(0);

        const throttlePercent = Math.abs((engineForce / (maxEngineForce * 2.5)) * 100);
        throttleEl.textContent = Math.min(100, throttlePercent).toFixed(0) + '%';
        coinCountEl.textContent = gameData.coins;
        
        updateEngineSound(displaySpeed, inputState.keyW || inputState.keyS);

        // ** Police Timer HUD update **
        if(isPoliceModeActive && !policeActive) {
            let timeLeft = (policeSpawnTime - performance.now()) / 1000;
            if(timeLeft <= 0) {
                spawnPolice();
                document.getElementById('police-timer').innerText = "POLICE ACTIVE";
            } else {
                document.getElementById('police-timer').innerText = `SPAWN IN: ${timeLeft.toFixed(1)}s`;
            }
        }
    }
    
    function updateColliders() {
        if (!chassisBody) return;
        
        const chassisPos = new THREE.Vector3(chassisBody.position.x, chassisBody.position.y, chassisBody.position.z);

        // Dynamic addition/removal of static bodies (buildings) for performance
        staticBodies.forEach(obj => {
            const d = chassisPos.distanceTo(obj.center);
            if (!obj.added && d <= obj.radius + 200) {
                world.addBody(obj.body);
                obj.added = true;
            } else if (obj.added && d > obj.radius + 300) { // Larger distance to remove to prevent pop-in/out
                world.removeBody(obj.body);
                obj.added = false;
            }
        });

        // Dynamic coin collection visibility/removal for performance
        for(let i = coinBodies.length - 1; i >= 0; i--) {
            const coinBody = coinBodies[i];
            const coinMesh = coinMeshes[i];
            const d = chassisPos.distanceTo(new THREE.Vector3().copy(coinBody.position));
            
            // Remove coin if too far away (and re-add later if needed)
            if (d > 500) {
                world.removeBody(coinBody);
                scene.remove(coinMesh);
                coinBodies.splice(i, 1);
                coinMeshes.splice(i, 1);
            }
        }
        
        // Refill coins if quantity drops too low
        if (coinBodies.length < COIN_MIN) {
            spawnCoins(COIN_MAX - coinBodies.length);
        }
    }

    function updateTargetArrow() {
        if (!targetArrowMesh || !isDeliveryModeActive || currentMission.status === 'none' || currentMission.status === 'completed') {
            if(targetArrowMesh) targetArrowMesh.visible = false;
            return;
        }

        let targetPos = null;
        let targetColor = null;

        if (currentMission.status === 'pickup') {
            targetPos = currentMission.pickupPoint.position;
            targetColor = targetArrowMesh.userData.pickupColor;
        } else if (currentMission.status === 'delivering') {
            targetPos = currentMission.deliveryTarget.position;
            targetColor = targetArrowMesh.userData.deliveryColor;
        } else {
            targetArrowMesh.visible = false;
            return;
        }

        targetArrowMesh.visible = true;

        targetArrowMesh.traverse((node) => {
            if (node.isMesh && node.material.color) {
                node.material.color.copy(targetColor);
            }
        });

        const _tempCarPosition = chassisBody.position;
        // Place the arrow 2.5m above the car
        targetArrowMesh.position.set(_tempCarPosition.x, _tempCarPosition.y + 2.5, _tempCarPosition.z);

        const lookAtTarget = new THREE.Vector3(targetPos.x, targetArrowMesh.position.y, targetPos.z);
        
        // Rotate arrow to point at target
        targetArrowMesh.rotation.set(0, 0, 0); 
        targetArrowMesh.lookAt(lookAtTarget);
        targetArrowMesh.rotateY(Math.PI); 
        targetArrowMesh.rotateY(Math.PI / 2); 
        targetArrowMesh.rotateX(Math.PI / 4); 
        targetArrowMesh.position.y += 0.5; 
    }


    function animate(time) {
        if(isGameRunning || !isGameRunning) requestAnimationFrame(animate);

        if (!chassisBody || !world) return;

        if (isGameRunning) {
            const fixedTimeStep = 1/60;
            const maxSubSteps = 1;
            
            if (lastTime !== undefined) {
                const dt = (time - lastTime) / 1000;
                world.step(fixedTimeStep, dt, maxSubSteps);
            } else {
                world.step(fixedTimeStep);
            }
            lastTime = time;

            updateControls();
            updateColliders();
            
            if (isDeliveryModeActive) {
                updateDeliveryMode();
                updateTargetArrow();
            } else if (targetArrowMesh) {
                targetArrowMesh.visible = false;
            }
            
            if (isPoliceModeActive) {
                if(policeActive) updatePoliceAI();
            }
        }

        // Model position synchronization
        for (let i = 0; i < vehicle.wheelInfos.length; i++) {
            vehicle.updateWheelTransform(i);
            let t = vehicle.wheelInfos[i].worldTransform;
            if (wheelMeshes[i]) {
                wheelMeshes[i].position.copy(t.position);
                wheelMeshes[i].quaternion.copy(t.quaternion);
            }
        }

        if (carMesh) {
            carMesh.position.copy(chassisBody.position);
            carMesh.quaternion.copy(chassisBody.quaternion);
            carMesh.position.y += VISUAL_Y_OFFSET; // Correct visual offset
        }

        // Coin rotation
        coinMeshes.forEach(mesh => {
            mesh.rotation.y += 0.05;
        });

        // Camera update
        if (cameraMode === 'chase') {
            const desiredOffset = new THREE.Vector3(0, 15, -30);
            desiredOffset.applyQuaternion(carMesh.quaternion);
            desiredOffset.add(carMesh.position);

            const smoothSpeed = 0.1;
            cameraChase.position.lerp(desiredOffset, smoothSpeed);
            cameraChase.lookAt(carMesh.position);
        } else {
            // Cockpit camera is parented to carMesh, so only its projection needs update
        }

        renderer.render(scene, currentCamera);
    }
    
    // =============================================================================
    // ** INITIALIZATION **
    // =============================================================================
    
    function initSystem() {
        loadGameData(); 
        setupMobileControls();
        
        initThree();
        initCannon();
        initGround();
        initCameraAndLights();
        initLoaders();
        loadCarModel();
        loadTireModel();
        loadCity();
        loadCoinPrototype();
        loadArrowModel(); 
        
        applyUpgrades(); // Apply any saved upgrades
    }

    window.enterGame = function() { 
        if(!audioCtx) initAudio(); 
        document.getElementById('splash').style.opacity = '0';
        setTimeout(() => {
            document.getElementById('splash').style.display = 'none';
            document.getElementById('hud-layer').style.display = 'flex';
        }, 500);
        
        isGameRunning = true; 
        isPoliceModeActive = false; // Reset modes
        if(isDeliveryModeActive) deliveryHudEl.style.display = 'block';
        document.getElementById('police-hud').style.display = 'none'; // Ensure police HUD is off when not in mode
        
        // Initial coin spawn if game starts in freeroam
        if(coinBodies.length === 0) spawnCoins(COIN_MAX);
    }
    
    window.addEventListener('resize', () => {
        if (renderer && cameraChase && cameraCockpit) {
            renderer.setSize(window.innerWidth, window.innerHeight);
            const aspect = window.innerWidth / window.innerHeight;
            cameraChase.aspect = aspect;
            cameraChase.updateProjectionMatrix();
            cameraCockpit.aspect = aspect;
            cameraCockpit.updateProjectionMatrix();
        }
    });

    document.addEventListener('DOMContentLoaded', initSystem);

    </script>
</body>
</html>
