<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <title>OPEN WORLD HYPER DRIVE - POLICE CHASE</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* =========================================================================
         * UI BASE & TYPOGRAPHY
         * ========================================================================= */
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000000; 
            font-family: 'Rajdhani', sans-serif; 
            color: #E0FFFF;
            user-select: none; 
            -webkit-user-select: none;
            touch-action: none; 
        }
        
        /* =========================================================================
         * HUD (IN-GAME INTERFACE)
         * ========================================================================= */
        #hud-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
            padding: 30px; box-sizing: border-box; z-index: 10;
        }

        .hud-top-left { display: flex; gap: 20px; flex-wrap: wrap; }
        .hud-top-right { position: absolute; top: 30px; right: 30px; }
        
        .instrument {
            background: rgba(0, 15, 30, 0.7);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-left: 5px solid #00FFFF;
            backdrop-filter: blur(10px);
            padding: 12px 22px;
            min-width: 120px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.1);
            border-radius: 4px;
            clip-path: polygon(0 0, 100% 0, 100% 80%, 90% 100%, 0 100%);
        }
        
        .label {
            font-family: 'Orbitron', sans-serif; font-size: 10px; color: #00FFFF; 
            font-weight: 700; letter-spacing: 2px; margin-bottom: 3px; display:block; 
            text-transform: uppercase; text-shadow: 0 0 5px rgba(0, 255, 255, 0.8);
        }
        .value {
            font-family: 'Orbitron', sans-serif; font-size: 36px; font-weight: 900; 
            letter-spacing: -2px; line-height: 1; color: #FFFFFF;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }
        .unit { font-size: 14px; color: #888888; margin-left: 6px; font-weight: 400; }

        .spd-color { border-left-color: #00FFFF !important; }
        .rpm-color { border-left-color: #FF00FF !important; }
        .gear-color { border-left-color: #FFD700 !important; }
        .throttle-color { border-left-color: #00FF00 !important; }

        #hud-coin {
            background: rgba(35, 18, 0, 0.7);
            border: 1px solid rgba(255, 215, 0, 0.15);
            border-left: 5px solid #FFD700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.06);
            min-width: 140px; margin-bottom: 20px;
        }
        #hud-coin .label { color: #FFD700; }
        #coin-count { font-size: 40px; letter-spacing: 2px; color: #FFD700; }

        /* ** Delivery HUD Style ** */
        #delivery-hud {
            position: absolute; top: 180px; left: 30px;
            background: rgba(0, 30, 0, 0.7);
            border: 1px solid rgba(0, 255, 0, 0.2);
            border-left: 5px solid #00FF00;
            backdrop-filter: blur(10px);
            padding: 15px 20px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.1);
            border-radius: 4px;
            min-width: 250px;
            display: none; 
        }
        #delivery-hud .mission-title { 
            font-family: 'Orbitron', sans-serif; font-size: 14px; color: #00FF00; 
            margin-bottom: 8px; font-weight: 700; border-bottom: 1px dashed rgba(0, 255, 0, 0.3);
            padding-bottom: 5px;
        }
        #delivery-hud .mission-detail { font-size: 16px; color: #E0FFE0; margin-bottom: 5px; }
        #delivery-distance-value { font-family: 'Orbitron', sans-serif; font-weight: 900; font-size: 24px; color: #FFFFFF; }
        #delivery-timer-value { font-family: 'Orbitron', sans-serif; font-weight: 900; font-size: 24px; color: #FFD700; }

        /* ** Police HUD Style ** */
        #police-hud {
            position: absolute; top: 120px; left: 50%; transform: translateX(-50%);
            text-align: center; display: none;
        }
        #police-alert {
            font-family: 'Orbitron', sans-serif; font-size: 28px; font-weight: 900;
            color: #FF0000; text-shadow: 0 0 15px red; letter-spacing: 3px;
            animation: blinkRed 0.5s infinite alternate;
        }
        #police-timer {
            font-family: 'Orbitron'; font-size: 20px; color: #fff; margin-top: 5px;
        }
        @keyframes blinkRed { from { opacity: 1; } to { opacity: 0.3; } }

        /* ** BUSTED SCREEN ** */
        #busted-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 50, 0.8); z-index: 2000; display: none;
            flex-direction: column; align-items: center; justify-content: center;
        }
        #busted-text {
            font-family: 'Orbitron'; font-size: 100px; color: #FF0000; font-weight: 900;
            text-shadow: 0 0 30px #FF0000; transform: rotate(-10deg); border: 5px solid red;
            padding: 10px 40px; letter-spacing: 10px;
        }
        #busted-restart-btn {
            margin-top: 50px; padding: 20px 60px; font-size: 24px; font-family: 'Orbitron';
            background: white; border: none; cursor: pointer; font-weight: bold;
        }

        #control-hints {
            position: absolute; bottom: 30px; left: 30px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-left: 5px solid #00FF00;
            backdrop-filter: blur(10px); padding: 18px 25px;
            color: #eee; font-size: 13px; border-radius: 4px;
            max-width: 250px; line-height: 1.8;
        }
        .respawn-hint { color: #FFD700; font-weight: bold; }
        .hint-title { color: #00FF00; font-family: 'Orbitron', sans-serif; font-weight: bold; margin-bottom: 10px; border-bottom: 1px solid rgba(0, 255, 0, 0.3); padding-bottom: 5px; }
        .copyright-tag { position: fixed; bottom: 15px; right: 15px; font-size: 12px; color: rgba(255, 255, 255, 0.3); z-index: 10; }

        /* =========================================================================
         * MOBILE CONTROLS
         * ========================================================================= */
        #mobile-controls {
            display: none; 
            position: absolute; bottom: 20px; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 20;
        }
        .touch-btn {
            position: absolute; pointer-events: auto;
            background: rgba(0, 255, 255, 0.15); border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 50%; width: 80px; height: 80px;
            backdrop-filter: blur(4px); touch-action: none;
            display: flex; align-items: center; justify-content: center;
        }
        .touch-btn:active { background: rgba(0, 255, 255, 0.5); }
        .touch-btn svg { width: 40px; height: 40px; fill: #fff; }
        
        #btn-left { bottom: 30px; left: 30px; }
        #btn-right { bottom: 30px; left: 130px; }
        #btn-brake { bottom: 30px; right: 140px; width: 60px; height: 60px; border-color: #ff0055; background: rgba(255, 0, 85, 0.2); }
        #btn-gas { bottom: 40px; right: 30px; width: 90px; height: 90px; border-color: #00ff00; background: rgba(0, 255, 0, 0.2); }
        #btn-respawn-mob { top: 100px; right: 20px; width: 50px; height: 50px; border-radius: 8px; font-family: 'Orbitron'; font-weight: bold; color: yellow; border-color: yellow;}
        #btn-camera-mob { top: 100px; left: 20px; width: 50px; height: 50px; border-radius: 8px; font-family: 'Orbitron'; font-weight: bold; color: cyan; }

        /* =========================================================================
         * SPLASH / MAIN MENU UI
         * ========================================================================= */
        #splash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(0,0,0,0.6) 0%, rgba(0,0,0,0) 30%, rgba(0,0,0,0) 70%, rgba(0,0,0,0.8) 100%);
            z-index: 999;
            display: flex; 
            align-items: center;
            justify-content: center;
            cursor: grab;
            transition: opacity 0.5s; 
        }
        #splash:active { cursor: grabbing; }

        .splash-header {
            position: absolute; top: 60px; left: 0; width: 100%;
            text-align: center; pointer-events: none;
        }
        h1 {
            font-family: 'Orbitron', sans-serif; font-size: 64px; margin: 0; font-weight: 900;
            letter-spacing: 12px; text-transform: uppercase;
            background: linear-gradient(to right, #00FFFF, #FFFFFF, #FF00FF);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 0 35px rgba(0, 255, 255, 0.7), 0 0 5px rgba(255, 255, 255, 0.5);
        }
        .splash-subtitle {
            font-family: 'Rajdhani', sans-serif; font-size: 20px; color: rgba(0, 255, 255, 0.8);
            letter-spacing: 6px; margin-top: 10px; font-weight: 600;
        }

        .splash-top-right {
            position: absolute; top: 40px; right: 40px;
            text-align: right; pointer-events: none;
        }
        .splash-top-right .label { font-size: 12px; color: #FFD700; text-shadow: 0 0 10px #FFD700; margin-bottom: 5px;}
        .splash-top-right .value { font-size: 42px; color: #FFD700; text-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }

        .splash-left-menu {
            position: absolute; top: 50%; left: 40px;
            transform: translateY(-50%);
            pointer-events: none;
        }
        .splash-left-menu .label { color: #00FFFF; font-size: 16px; margin-bottom: 5px; }
        .splash-left-menu .value { font-size: 28px; color: #FFFFFF; text-shadow: 0 0 10px rgba(255, 255, 255, 0.5); }
        .splash-left-menu div { margin-bottom: 25px; }


        #splash-controls {
            display: flex; gap: 20px; position: absolute; bottom: 80px;
            font-family: 'Orbitron';
        }
        .control-btn {
            padding: 15px 30px; font-size: 18px; font-weight: bold; cursor: pointer;
            border: 3px solid #00FFFF; background: rgba(0, 255, 255, 0.2);
            color: #FFFFFF; text-shadow: 0 0 10px #00FFFF;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            border-radius: 5px; transition: all 0.2s;
        }
        .control-btn:hover { background: rgba(0, 255, 255, 0.5); box-shadow: 0 0 30px #00FFFF; }
        .control-btn:active { transform: scale(0.95); }
        .active-mode { border-color: #FFD700; background: rgba(255, 215, 0, 0.3); color: #FFD700; box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }


        #splash-start-text {
            font-family: 'Orbitron'; font-size: 24px; color: #FFFFFF; 
            text-shadow: 0 0 20px #FFFFFF; letter-spacing: 5px;
            position: absolute; bottom: 30px;
            animation: pulseWhite 1.5s infinite alternate;
        }
        @keyframes pulseWhite { from { opacity: 1; } to { opacity: 0.5; } }


        /* =========================================================================
         * CANVAS
         * ========================================================================= */
        canvas {
            display: block; 
            filter: brightness(1.1) contrast(1.1);
        }
    </style>
</head>
<body>

    <div id="splash">
        <div class="splash-header">
            <h1>HYPER DRIVE</h1>
            <div class="splash-subtitle">OPEN WORLD PURSUIT SIM</div>
        </div>
        
        <div class="splash-top-right">
            <span class="label">HIGH SCORE</span>
            <div class="value" id="high-score-value">0</div>
        </div>

        <div class="splash-left-menu">
            <div>
                <span class="label">PHYSICS ENGINE</span>
                <div class="value">CANNON.JS</div>
            </div>
            <div>
                <span class="label">RENDER ENGINE</span>
                <div class="value">THREE.JS</div>
            </div>
        </div>

        <div id="splash-controls">
            <div class="control-btn active-mode" id="mode-free">FREE ROAM</div>
            <div class="control-btn" id="mode-delivery">DELIVERY RUSH</div>
            <div class="control-btn" id="mode-police">POLICE CHASE</div>
        </div>

        <div id="splash-start-text">CLICK OR TAP TO START</div>
    </div>

    <div id="hud-layer" style="display: none;">
        <div class="hud-top-left">
            <div class="instrument spd-color">
                <span class="label">SPEED</span>
                <div class="value"><span id="speed-value">0</span><span class="unit">KM/H</span></div>
            </div>
            <div class="instrument rpm-color">
                <span class="label">RPM</span>
                <div class="value"><span id="rpm-value">0</span><span class="unit">K</span></div>
            </div>
            <div class="instrument gear-color">
                <span class="label">GEAR</span>
                <div class="value" id="gear-value">N</div>
            </div>
            <div class="instrument throttle-color">
                <span class="label">THROTTLE</span>
                <div class="value"><span id="throttle-value">0</span><span class="unit">%</span></div>
            </div>
        </div>

        <div class="hud-top-right">
            <div class="instrument" id="hud-coin">
                <span class="label">COINS</span>
                <div class="value" id="coin-count">0</div>
            </div>
        </div>

        <div id="police-hud">
            <div id="police-alert">WANTED!</div>
            <div id="police-timer">EVASION TIME: 00:00</div>
        </div>
        
        <div id="delivery-hud">
            <div class="mission-title">DELIVERY MISSION</div>
            <div class="mission-detail">DISTANCE: <span id="delivery-distance-value">0</span> m</div>
            <div class="mission-detail">TIME LEFT: <span id="delivery-timer-value">--:--</span></div>
        </div>

        <div id="control-hints">
            <div class="hint-title">CONTROLS</div>
            <div>**W / UP:** Accelerate</div>
            <div>**S / DOWN:** Brake / Reverse</div>
            <div>**A / LEFT:** Steer Left</div>
            <div>**D / RIGHT:** Steer Right</div>
            <div>**SPACE:** Handbrake</div>
            <div class="respawn-hint">**R:** Respawn Car</div>
            <div>**C:** Change Camera</div>
        </div>
    </div>

    <div id="busted-screen">
        <div id="busted-text">BUSTED</div>
        <button id="busted-restart-btn">RESTART</button>
    </div>

    <div id="mobile-controls">
        <div class="touch-btn" id="btn-left">
            <svg viewBox="0 0 24 24"><path d="M15 18l-6-6 6-6v12z"/></svg>
        </div>
        <div class="touch-btn" id="btn-right">
            <svg viewBox="0 0 24 24"><path d="M9 18l6-6-6-6v12z"/></svg>
        </div>
        <div class="touch-btn" id="btn-brake">BRAKE</div>
        <div class="touch-btn" id="btn-gas">GAS</div>
        <div class="touch-btn" id="btn-respawn-mob">R</div>
        <div class="touch-btn" id="btn-camera-mob">C</div>
    </div>

    <div class="copyright-tag">Powered by Three.js & CANNON.js</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/controls/OrbitControls.js"></script>

    <script>
        // =========================================================================
        // GLOBAL VARIABLES
        // =========================================================================

        // Rendering and Physics
        let scene, cameraChase, cameraCockpit, currentCamera, renderer, world;
        let lastTime;

        // Models and Textures
        let carMesh, tireMesh, policeMesh, policeWheels = [];
        let coinPrototype, arrowMesh;
        const textureLoader = new THREE.TextureLoader();
        const gltfLoader = new THREE.GLTFLoader();

        // Car Physics Variables
        let body, vehicle;
        let policeBody, policeVehicle;
        const maxSteerVal = 0.5; // Max steering angle (in radians)
        const maxForce = 5000;   // Max engine force
        const maxBrakeForce = 10; // Max brake force
        const handbrakeForce = 1000;
        const chassisWidth = 2.0;
        const chassisHeight = 0.8;
        const chassisLength = 4.5;
        const wheelRadius = 0.45;
        const wheelThickness = 0.3;
        const wheelBase = 1.6;
        const axleWidth = 0.9;
        const chassisMass = 150;
        const SCALE_FACTOR = 1.0;

        // Input and State
        const keys = {
            W: false, S: false, A: false, D: false, SPACE: false, R: false
        };
        let currentThrottle = 0;
        let currentBrake = 0;
        let currentSteering = 0;
        let isGameRunning = false;
        let currentCameraMode = 'CHASE'; // 'CHASE', 'COCKPIT'

        // Game Modes
        let isPoliceModeActive = false;
        let isDeliveryModeActive = false;
        let policeTimer = 0;
        let policeBustedTime = 10; // Time in seconds before getting busted
        let policeSpawnDistance = 50;
        let policeDespawnDistance = 200;

        // Delivery Mission
        let deliveryTargetPosition = null;
        let deliveryTimer = 0;
        let deliveryMaxTime = 180; // 3 minutes
        let coins = 0;
        let highScore = 0;
        let arrowHelper;
        const deliveryHudEl = document.getElementById('delivery-hud');
        const policeHudEl = document.getElementById('police-hud');
        const bustedScreenEl = document.getElementById('busted-screen');
        const restartBtn = document.getElementById('busted-restart-btn');

        // Audio
        let audioCtx;
        let engineOscillator, engineGain, sirenSource;


        // =========================================================================
        // INITIALIZATION
        // =========================================================================

        function initAudio() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            
            // Engine Sound Setup
            engineOscillator = audioCtx.createOscillator();
            engineOscillator.type = 'sawtooth';
            engineGain = audioCtx.createGain();
            engineGain.gain.value = 0; // Start muted
            
            engineOscillator.connect(engineGain);
            engineGain.connect(audioCtx.destination);
            engineOscillator.start();

            // Siren Setup (Placeholder - requires a source, e.g., an AudioBufferSourceNode)
            // For simplicity, we'll just use the volume logic for siren in animate loop
        }

        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 100, 300); 

            // Chase Camera (Default)
            cameraChase = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            cameraChase.position.set(0, 5, -10); // Initial position relative to the car

            // Cockpit Camera
            cameraCockpit = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            cameraCockpit.position.set(0, 1.5, -0.5); // Initial position inside the car

            currentCamera = cameraChase;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 1);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
        }

        function initCannon() {
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0); // Standard gravity
            world.broadphase = new CANNON.SAPBroadphase(world);
            world.solver.iterations = 10;
        }

        function initGround() {
            // THREE.js Ground Mesh
            const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x333333,
                map: textureLoader.load('https://threejs.org/examples/textures/crate.gif', (texture) => {
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.repeat.set(50, 50);
                })
            });
            const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);

            // CANNON.js Ground Body
            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({ mass: 0 });
            groundBody.addShape(groundShape);
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.addBody(groundBody);

            // Physics Material
            const groundCarContactMaterial = new CANNON.ContactMaterial(
                new CANNON.Material("groundMaterial"),
                new CANNON.Material("carMaterial"),
                {
                    friction: 0.5,
                    restitution: 0.1,
                    contactEquationStiffness: 1e8,
                    contactEquationRelaxation: 3
                }
            );
            world.addContactMaterial(groundCarContactMaterial);
        }

        function initCameraAndLights() {
            // Directional Light (Sun)
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(100, 200, 50);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.near = 1;
            dirLight.shadow.camera.far = 500;
            dirLight.shadow.camera.left = -200;
            dirLight.shadow.camera.right = 200;
            dirLight.shadow.camera.top = 200;
            dirLight.shadow.camera.bottom = -200;
            scene.add(dirLight);

            // Ambient Light
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);

            // Sky
            scene.background = new THREE.Color(0x000033);
        }

        function initLoaders() {
            // GLTF Loader is already loaded via CDN
        }


        // =========================================================================
        // GAME OBJECT CREATION (Player Car)
        // =========================================================================

        function loadCarModel() {
            // Placeholder: A simple BoxGeometry if a complex model is not loaded
            const carGeometry = new THREE.BoxGeometry(chassisWidth * SCALE_FACTOR, chassisHeight * SCALE_FACTOR, chassisLength * SCALE_FACTOR);
            const carMaterial = new THREE.MeshPhongMaterial({ color: 0x00FFFF });
            carMesh = new THREE.Mesh(carGeometry, carMaterial);
            carMesh.castShadow = true;
            carMesh.receiveShadow = false;
            scene.add(carMesh);

            createCarPhysics(new CANNON.Vec3(0, 10, 0));
        }

        function loadTireModel() {
            const tireGeometry = new THREE.CylinderGeometry(wheelRadius * SCALE_FACTOR, wheelRadius * SCALE_FACTOR, wheelThickness * SCALE_FACTOR, 12);
            const tireMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            tireMesh = new THREE.Mesh(tireGeometry, tireMaterial);
            // Hide the prototype mesh
            tireMesh.visible = false; 
            scene.add(tireMesh);
        }

        function createCarPhysics(initialPosition) {
            // Chassis Body
            const chassisShape = new CANNON.Box(new CANNON.Vec3(chassisWidth * SCALE_FACTOR / 2, chassisHeight * SCALE_FACTOR / 2, chassisLength * SCALE_FACTOR / 2));
            body = new CANNON.Body({ mass: chassisMass, material: new CANNON.Material("carMaterial") });
            body.addShape(chassisShape);
            body.position.copy(initialPosition);
            world.addBody(body);

            // Vehicle
            vehicle = new CANNON.RaycastVehicle({
                chassisBody: body
            });

            const makeWheelOptions = (side, up, forward) => ({
                radius: wheelRadius * SCALE_FACTOR,
                directionLocal: new CANNON.Vec3(0, -1, 0),
                suspensionStiffness: 30,
                suspensionRestLength: 0.3,
                frictionSlip: 5,
                dampingRelaxation: 2.3,
                rollInfluence: 0.01,
                maxSuspensionForce: 100000,
                isFrontWheel: Math.abs(forward) > 0,
                axleLocal: new CANNON.Vec3(1, 0, 0),
                chassisConnectionPointLocal: new CANNON.Vec3(side, up, forward)
            });

            // Add the 4 wheels
            vehicle.addWheel(makeWheelOptions(-axleWidth * SCALE_FACTOR, 0, wheelBase * SCALE_FACTOR)); // 0: Front Left
            vehicle.addWheel(makeWheelOptions( axleWidth * SCALE_FACTOR, 0, wheelBase * SCALE_FACTOR));  // 1: Front Right
            vehicle.addWheel(makeWheelOptions(-axleWidth * SCALE_FACTOR, 0, -wheelBase * SCALE_FACTOR)); // 2: Rear Left
            vehicle.addWheel(makeWheelOptions( axleWidth * SCALE_FACTOR, 0, -wheelBase * SCALE_FACTOR));  // 3: Rear Right
            
            vehicle.addToWorld(world);

            // Create a THREE.js mesh for each wheel
            for (let i = 0; i < vehicle.wheelInfos.length; i++) {
                const wheel = vehicle.wheelInfos[i];
                const wheelVisual = tireMesh.clone();
                wheelVisual.visible = true;
                wheelVisual.rotation.z = Math.PI / 2;
                carMesh.add(wheelVisual);
                vehicle.wheelInfos[i].mesh = wheelVisual;
            }
        }


        // =========================================================================
        // GAME OBJECT CREATION (Police Car)
        // =========================================================================

        function loadPoliceModel() {
            // Simple placeholder for police car mesh
            const policeGeometry = new THREE.BoxGeometry(chassisWidth * SCALE_FACTOR, chassisHeight * SCALE_FACTOR, chassisLength * SCALE_FACTOR);
            const policeMaterial = new THREE.MeshPhongMaterial({ color: 0xCC0000 }); // Red/blue lights not implemented
            policeMesh = new THREE.Mesh(policeGeometry, policeMaterial);
            policeMesh.castShadow = true;
            policeMesh.receiveShadow = false;
            // scene.add(policeMesh); // Will be added by spawnPolice
        }

        function createPoliceVehicle(initialPosition) {
            // Chassis Body
            const chassisShape = new CANNON.Box(new CANNON.Vec3(chassisWidth * SCALE_FACTOR / 2, chassisHeight * SCALE_FACTOR / 2, chassisLength * SCALE_FACTOR / 2));
            policeBody = new CANNON.Body({ mass: chassisMass, material: new CANNON.Material("carMaterial") });
            policeBody.addShape(chassisShape);
            policeBody.position.copy(initialPosition);
            world.addBody(policeBody);

            // Vehicle
            policeVehicle = new CANNON.RaycastVehicle({
                chassisBody: policeBody
            });

            const makeWheelOptions = (side, up, forward) => ({
                radius: wheelRadius * SCALE_FACTOR,
                directionLocal: new CANNON.Vec3(0, -1, 0),
                suspensionStiffness: 30,
                suspensionRestLength: 0.3,
                frictionSlip: 5,
                dampingRelaxation: 2.3,
                rollInfluence: 0.01,
                maxSuspensionForce: 100000,
                isFrontWheel: Math.abs(forward) > 0,
                axleLocal: new CANNON.Vec3(1, 0, 0),
                chassisConnectionPointLocal: new CANNON.Vec3(side, up, forward)
            });

            // Add the 4 wheels for the police vehicle
            policeVehicle.addWheel(makeWheelOptions(-axleWidth * SCALE_FACTOR, 0, wheelBase * SCALE_FACTOR));
            policeVehicle.addWheel(makeWheelOptions( axleWidth * SCALE_FACTOR, 0, wheelBase * SCALE_FACTOR));
            policeVehicle.addWheel(makeWheelOptions(-axleWidth * SCALE_FACTOR, 0, -wheelBase * SCALE_FACTOR));
            policeVehicle.addWheel(makeWheelOptions( axleWidth * SCALE_FACTOR, 0, -wheelBase * SCALE_FACTOR));
            
            // **FIX 1: ADD TO WORLD**
            policeVehicle.addToWorld(world); 

            // Create a THREE.js mesh for each wheel
            policeWheels = [];
            for (let i = 0; i < policeVehicle.wheelInfos.length; i++) {
                const wheelVisual = tireMesh.clone();
                wheelVisual.visible = true;
                wheelVisual.rotation.z = Math.PI / 2;
                policeMesh.add(wheelVisual);
                policeVehicle.wheelInfos[i].mesh = wheelVisual;
                policeWheels.push(wheelVisual);
            }

            scene.add(policeMesh);
        }

        function spawnPolice(targetPosition) {
            // 1. 清理现有的警车（如果有）
            if (policeVehicle) {
                // **FIX 2: Correct API call (removeFromWorld)**
                policeVehicle.removeFromWorld(world); 
                
                world.removeBody(policeBody);
                scene.remove(policeMesh);
                policeBody.isDead = true;

                // 清理警车车轮网格
                policeWheels.forEach(wheelMesh => policeMesh.remove(wheelMesh));
                policeWheels.length = 0; 
                scene.remove(policeMesh);
            }

            // 2. 计算新的生成位置 (Player + Offset)
            const offset = new CANNON.Vec3(policeSpawnDistance, 0, 0);
            
            // Apply a random rotation to the offset to spawn police car from a random direction
            const angle = Math.random() * 2 * Math.PI;
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            offset.x = policeSpawnDistance * cos;
            offset.z = policeSpawnDistance * sin;
            
            const policeSpawnPosition = new CANNON.Vec3(
                targetPosition.x + offset.x,
                targetPosition.y + 5, // Spawn slightly above ground to drop
                targetPosition.z + offset.z
            );
            
            // 3. 创建新的警车
            createPoliceVehicle(policeSpawnPosition);
            policeBody.isDead = false;

            // 4. 更新 HUD 
            policeHudEl.style.display = 'block';
            policeTimer = 0;
        }

        // =========================================================================
        // GAME OBJECT CREATION (City/Level)
        // =========================================================================

        function loadCity() {
            // Simple City: Add some buildings (Boxes)
            const buildingGeo = new THREE.BoxGeometry(10, 20, 10);
            const buildingMat = new THREE.MeshPhongMaterial({ color: 0x8888AA });

            for (let i = 0; i < 50; i++) {
                const x = (Math.random() - 0.5) * 500;
                const z = (Math.random() - 0.5) * 500;
                const height = 10 + Math.random() * 50;

                const buildingMesh = new THREE.Mesh(
                    new THREE.BoxGeometry(10, height, 10),
                    buildingMat.clone()
                );
                buildingMesh.position.set(x, height / 2, z);
                buildingMesh.castShadow = true;
                scene.add(buildingMesh);

                // Add to Cannon world
                const buildingShape = new CANNON.Box(new CANNON.Vec3(5, height / 2, 5));
                const buildingBody = new CANNON.Body({ mass: 0 });
                buildingBody.addShape(buildingShape);
                buildingBody.position.set(x, height / 2, z);
                world.addBody(buildingBody);
            }
        }

        function loadCoinPrototype() {
            // Coin model (Cylinder or simple Ring)
            const coinGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 12);
            const coinMat = new THREE.MeshBasicMaterial({ color: 0xFFD700 });
            coinPrototype = new THREE.Mesh(coinGeo, coinMat);
            coinPrototype.rotation.x = Math.PI / 2;
            coinPrototype.visible = false;
            scene.add(coinPrototype);
            
            // Create initial coins
            for (let i = 0; i < 15; i++) {
                spawnCoin();
            }
        }

        function spawnCoin() {
            const x = (Math.random() - 0.5) * 400;
            const z = (Math.random() - 0.5) * 400;
            const coinMesh = coinPrototype.clone();
            coinMesh.visible = true;
            coinMesh.position.set(x, 0.5, z);
            scene.add(coinMesh);

            // Simple invisible hit box for physics collision
            const coinShape = new CANNON.Cylinder(0.5, 0.5, 0.1, 12);
            const coinBody = new CANNON.Body({ mass: 0, isTrigger: true });
            coinBody.addShape(coinShape);
            coinBody.position.set(x, 0.5, z);
            
            // Store reference to mesh and type for collision handler
            coinBody.mesh = coinMesh;
            coinBody.type = 'coin';

            coinBody.addEventListener("collide", handleCollision);
            world.addBody(coinBody);
        }

        function loadArrowModel() {
            // Destination Arrow Helper
            const dir = new THREE.Vector3(0, 1, 0);
            const origin = new THREE.Vector3(0, 0, 0);
            const length = 5;
            const hex = 0x00FF00;
            arrowHelper = new THREE.ArrowHelper(dir, origin, length, hex);
            scene.add(arrowHelper);
            arrowHelper.visible = false;
        }

        function setDeliveryTarget(position) {
            if (deliveryTargetPosition) {
                // Remove old target marker (if any, in a real game)
            }

            // Simple Sphere marker for target
            const targetGeo = new THREE.SphereGeometry(2, 8, 8);
            const targetMat = new THREE.MeshBasicMaterial({ color: 0x00FF00, wireframe: true });
            const targetMesh = new THREE.Mesh(targetGeo, targetMat);
            targetMesh.position.set(position.x, 1, position.z);
            scene.add(targetMesh);

            // Set the new target
            deliveryTargetPosition = {
                x: position.x,
                z: position.z,
                mesh: targetMesh
            };

            // Start/reset timer
            deliveryTimer = deliveryMaxTime;
            deliveryHudEl.style.display = 'block';
            arrowHelper.visible = true;
        }

        function checkDeliveryCompletion() {
            if (!deliveryTargetPosition) return;

            const playerPos = body.position;
            const targetPos = deliveryTargetPosition;
            const distanceSq = (playerPos.x - targetPos.x) ** 2 + (playerPos.z - targetPos.z) ** 2;

            if (distanceSq < 10 * 10) { // If within 10 meters
                coins += 100;
                document.getElementById('coin-count').textContent = coins;
                
                // Cleanup old target
                scene.remove(deliveryTargetPosition.mesh);
                deliveryTargetPosition = null;
                deliveryHudEl.style.display = 'none';
                arrowHelper.visible = false;

                // Set a new random target
                const newX = (Math.random() - 0.5) * 400;
                const newZ = (Math.random() - 0.5) * 400;
                setDeliveryTarget({ x: newX, z: newZ });
            }
        }

        function spawnRandomDeliveryTarget() {
            const newX = (Math.random() - 0.5) * 400;
            const newZ = (Math.random() - 0.5) * 400;
            setDeliveryTarget({ x: newX, z: newZ });
        }


        // =========================================================================
        // INPUT HANDLERS
        // =========================================================================

        document.addEventListener('keydown', (event) => {
            if (!isGameRunning) return;
            switch (event.code) {
                case 'KeyW':
                case 'ArrowUp':
                    keys.W = true;
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    keys.S = true;
                    break;
                case 'KeyA':
                case 'ArrowLeft':
                    keys.A = true;
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    keys.D = true;
                    break;
                case 'Space':
                    keys.SPACE = true;
                    break;
                case 'KeyR':
                    respawnCar();
                    break;
                case 'KeyC':
                    toggleCamera();
                    break;
            }
        });

        document.addEventListener('keyup', (event) => {
            if (!isGameRunning) return;
            switch (event.code) {
                case 'KeyW':
                case 'ArrowUp':
                    keys.W = false;
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    keys.S = false;
                    break;
                case 'KeyA':
                case 'ArrowLeft':
                    keys.A = false;
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    keys.D = false;
                    break;
                case 'Space':
                    keys.SPACE = false;
                    break;
            }
        });

        // =========================================================================
        // MOBILE CONTROLS
        // =========================================================================

        function setupMobileControls() {
            const isMobile = /Mobi|Android/i.test(navigator.userAgent);
            if (!isMobile) {
                document.getElementById('mobile-controls').style.display = 'none';
                return;
            }
            document.getElementById('mobile-controls').style.display = 'block';

            const addTouchListener = (id, key, eventType) => {
                const el = document.getElementById(id);
                if (!el) return;
                el.addEventListener('touchstart', (e) => { 
                    e.preventDefault(); 
                    if (!isGameRunning) return;
                    if (key === 'R') respawnCar();
                    else if (key === 'C') toggleCamera();
                    else keys[key] = true; 
                }, { passive: false });
                el.addEventListener('touchend', (e) => { 
                    e.preventDefault(); 
                    if (!isGameRunning) return;
                    if (key !== 'R' && key !== 'C') keys[key] = false; 
                }, { passive: false });
            };

            addTouchListener('btn-gas', 'W');
            addTouchListener('btn-brake', 'S');
            addTouchListener('btn-left', 'A');
            addTouchListener('btn-right', 'D');
            addTouchListener('btn-respawn-mob', 'R');
            addTouchListener('btn-camera-mob', 'C');
        }

        // =========================================================================
        // GAME LOGIC
        // =========================================================================

        function updateCarControl() {
            // Reset forces and steering
            vehicle.applyEngineForce(0, 2);
            vehicle.applyEngineForce(0, 3);
            vehicle.setBrake(0, 0);
            vehicle.setBrake(0, 1);
            vehicle.setBrake(0, 2);
            vehicle.setBrake(0, 3);

            currentThrottle = 0;
            currentBrake = 0;
            currentSteering = 0;

            // Steering
            if (keys.A) {
                currentSteering = maxSteerVal;
            } else if (keys.D) {
                currentSteering = -maxSteerVal;
            }
            vehicle.setSteeringValue(currentSteering, 0);
            vehicle.setSteeringValue(currentSteering, 1);

            // Acceleration / Reverse
            if (keys.W) {
                vehicle.applyEngineForce(maxForce, 2);
                vehicle.applyEngineForce(maxForce, 3);
                currentThrottle = 1;
            } else if (keys.S) {
                const speed = body.velocity.length();
                if (speed > 0.5) {
                    // Brake when moving forward
                    vehicle.setBrake(maxBrakeForce, 0);
                    vehicle.setBrake(maxBrakeForce, 1);
                    vehicle.setBrake(maxBrakeForce, 2);
                    vehicle.setBrake(maxBrakeForce, 3);
                    currentBrake = 1;
                } else {
                    // Reverse when stopped
                    vehicle.applyEngineForce(-maxForce * 0.5, 2);
                    vehicle.applyEngineForce(-maxForce * 0.5, 3);
                    currentThrottle = -0.5;
                }
            }

            // Handbrake
            if (keys.SPACE) {
                vehicle.setBrake(handbrakeForce, 2);
                vehicle.setBrake(handbrakeForce, 3);
            }
        }

        function updateCarVisuals() {
            // Update car body position and rotation
            carMesh.position.copy(body.position);
            carMesh.quaternion.copy(body.quaternion);

            // Update wheel meshes
            for (let i = 0; i < vehicle.wheelInfos.length; i++) {
                vehicle.updateWheelTransform(i);
                const transform = vehicle.wheelInfos[i].worldTransform;
                const wheelMesh = vehicle.wheelInfos[i].mesh;
                
                wheelMesh.position.copy(transform.position);
                wheelMesh.quaternion.copy(transform.quaternion);
            }

            // Update camera position
            updateCamera();
        }

        function updatePoliceVisuals() {
            if (!policeBody || policeBody.isDead) return;

            // Update police body position and rotation
            policeMesh.position.copy(policeBody.position);
            policeMesh.quaternion.copy(policeBody.quaternion);

            // Update police wheel meshes
            for (let i = 0; i < policeVehicle.wheelInfos.length; i++) {
                policeVehicle.updateWheelTransform(i);
                const transform = policeVehicle.wheelInfos[i].worldTransform;
                const wheelMesh = policeVehicle.wheelInfos[i].mesh;
                
                wheelMesh.position.copy(transform.position);
                wheelMesh.quaternion.copy(transform.quaternion);
            }
        }

        function updateCamera() {
            const carPosition = carMesh.position;
            const carQuaternion = carMesh.quaternion;

            if (currentCameraMode === 'CHASE') {
                // Chase camera logic (a smooth follow cam)
                const offset = new THREE.Vector3(0, 3, -10); // Back and up
                offset.applyQuaternion(carQuaternion);
                offset.add(carPosition);

                cameraChase.position.lerp(offset, 0.1);
                
                const target = carPosition.clone().add(new THREE.Vector3(0, 1.5, 0)); // Look slightly above the car
                cameraChase.lookAt(target);
            } else if (currentCameraMode === 'COCKPIT') {
                // Cockpit camera logic (fixed relative to car)
                const cockpitOffset = new THREE.Vector3(0, 1.5, 0.5); // Inside cabin, slightly forward
                cockpitOffset.applyQuaternion(carQuaternion);
                cockpitOffset.add(carPosition);

                cameraCockpit.position.copy(cockpitOffset);
                
                const targetForward = new THREE.Vector3(0, 1.5, 10); // Look forward
                targetForward.applyQuaternion(carQuaternion);
                targetForward.add(carPosition);
                
                cameraCockpit.lookAt(targetForward);
            }
        }
        
        function toggleCamera() {
            if (currentCameraMode === 'CHASE') {
                currentCameraMode = 'COCKPIT';
                currentCamera = cameraCockpit;
            } else {
                currentCameraMode = 'CHASE';
                currentCamera = cameraChase;
            }
        }

        function respawnCar() {
            // Stop motion
            body.velocity.set(0, 0, 0);
            body.angularVelocity.set(0, 0, 0);

            // Reset position slightly above the ground
            body.position.set(0, 10, 0); 
            
            // Reset rotation (face forward)
            body.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), 0);
        }

        function updateEngineSound() {
            if (!audioCtx) return;
            
            const speed = body.velocity.length();
            
            // Speed (0 to ~80 m/s -> RPM 0 to 1)
            const rpmFactor = Math.min(1, speed / 80); 
            
            // Pitch (frequency) modulation: 100 Hz (idle) to 800 Hz (high speed)
            const newFreq = 100 + rpmFactor * 700;
            engineOscillator.frequency.setValueAtTime(newFreq, audioCtx.currentTime);
            
            // Volume modulation: 0 (stopped) to 0.5 (full speed)
            const newGain = 0.1 + rpmFactor * 0.4;
            engineGain.gain.setValueAtTime(newGain, audioCtx.currentTime);
        }

        function updatePoliceAI(deltaTime) {
            if (!isPoliceModeActive || !policeBody || policeBody.isDead || !playerBody || !vehicle) return;

            // Assume constants are globally available (maxSteerVal, maxForce, maxBrakeForce)
            
            // 1. Calculate relative position and distance
            const toPlayer = body.position.vsub(policeBody.position);
            const distance = toPlayer.length();

            // 2. Despawn Police if too far away
            if (distance > policeDespawnDistance) {
                spawnPolice(body.position); // Respawn closer
                return;
            }

            // 3. Calculate Angle Difference
            // Get car's forward vector (police car is Z-axis)
            const policeDirection = new CANNON.Vec3(0, 0, 1);
            policeBody.quaternion.vmult(policeDirection, policeDirection); 

            // Normalize target vector
            const targetDirection = toPlayer.clone().unit();

            // Calculate the angle difference in 2D (XZ plane)
            // atan2(cross product, dot product) for signed angle
            const cross = policeDirection.x * targetDirection.z - policeDirection.z * targetDirection.x; 
            const dot = policeDirection.x * targetDirection.x + policeDirection.z * targetDirection.z; 
            let angleDiff = Math.atan2(cross, dot); 

            // 4. Steering Control (Optimized)
            // maxSteerVal is typically 0.5 radians (around 28 degrees)
            const maxSteeringAngle = maxSteerVal; 
            const angleThreshold = Math.PI / 4; // 45 degrees
            
            // Scale steering based on angle, maxing out the scaling at angleThreshold
            const steeringFactor = Math.min(1.0, Math.abs(angleDiff) / angleThreshold); 
            
            // Determine direction and apply scaled steering
            let steer = angleDiff > 0 ? -maxSteeringAngle * steeringFactor : maxSteeringAngle * steeringFactor;

            // Apply steering to front wheels (0 and 1)
            policeVehicle.setSteeringValue(steer, 0);
            policeVehicle.setSteeringValue(steer, 1);
            
            // 5. Throttle/Brake Control (Optimized)
            const policeSpeed = policeBody.velocity.length();

            // A. Brake Check: Too close OR sharp turn
            if (distance < 15 || (Math.abs(angleDiff) > 0.4 && policeSpeed > 10)) {
                
                policeVehicle.setBrake(maxBrakeForce * 1.5, 0);
                policeVehicle.setBrake(maxBrakeForce * 1.5, 1);
                policeVehicle.setBrake(maxBrakeForce * 0.8, 2);
                policeVehicle.setBrake(maxBrakeForce * 0.8, 3);

                policeVehicle.applyEngineForce(0, 2); 
                policeVehicle.applyEngineForce(0, 3);
            } 
            // B. Full Throttle Check: Far away AND reasonable aim
            else if (distance > 25 && Math.abs(angleDiff) < 0.35) {
                
                policeVehicle.setBrake(0, 0);
                policeVehicle.setBrake(0, 1);
                policeVehicle.setBrake(0, 2);
                policeVehicle.setBrake(0, 3);
                
                // Gradually increase throttle based on distance, capped at max force
                const throttle = Math.min(1.0, distance / 100.0); 
                policeVehicle.applyEngineForce(maxForce * throttle, 2);
                policeVehicle.applyEngineForce(maxForce * throttle, 3);
            } 
            // C. Cruise/Moderate Turn: Maintain momentum
            else {
                policeVehicle.setBrake(0, 0);
                policeVehicle.setBrake(0, 1);
                policeVehicle.setBrake(0, 2);
                policeVehicle.setBrake(0, 3);
                policeVehicle.applyEngineForce(maxForce * 0.3, 2); 
                policeVehicle.applyEngineForce(maxForce * 0.3, 3);
            }
        }


        function updateHUD(deltaTime) {
            if (!body) return;

            const speedMps = body.velocity.length();
            const speedKmh = Math.round(speedMps * 3.6); // m/s to km/h
            const rpm = Math.min(10, Math.round((speedMps / 80) * 10)); // Simple RPM approximation

            document.getElementById('speed-value').textContent = speedKmh;
            document.getElementById('rpm-value').textContent = rpm;
            document.getElementById('throttle-value').textContent = Math.round(Math.abs(currentThrottle) * 100);

            // Gear (Simple approximation)
            let gear = 'N';
            if (currentThrottle > 0) {
                gear = 'D';
            } else if (currentThrottle < 0) {
                gear = 'R';
            }
            document.getElementById('gear-value').textContent = gear;
            
            // Police Mode HUD
            if (isPoliceModeActive) {
                if (policeBody && !policeBody.isDead) {
                    const distance = body.position.vsub(policeBody.position).length();
                    
                    if (distance < 10) {
                        policeTimer += deltaTime;
                        if (policeTimer >= policeBustedTime) {
                            // BUSTED!
                            endGame(false); 
                            return;
                        }
                    } else {
                        // Slowly cool down when far away
                        policeTimer = Math.max(0, policeTimer - deltaTime * 0.5); 
                    }
                    
                    // Format timer
                    const timeRemaining = policeBustedTime - policeTimer;
                    const displayTime = Math.max(0, timeRemaining);
                    const seconds = Math.floor(displayTime);
                    const ms = Math.floor((displayTime - seconds) * 100);
                    document.getElementById('police-timer').textContent = `EVASION TIME: ${String(seconds).padStart(2, '0')}:${String(ms).padStart(2, '0')}`;
                } else {
                    // Police defeated or despawned - respawn a new one quickly
                    spawnPolice(body.position);
                }
            }

            // Delivery Mode HUD
            if (isDeliveryModeActive && deliveryTargetPosition) {
                deliveryTimer -= deltaTime;
                if (deliveryTimer <= 0) {
                    // Time's up!
                    endGame(true); // Game over for this mission
                    return;
                }

                // Update distance
                const playerPos = body.position;
                const targetPos = deliveryTargetPosition;
                const distance = Math.sqrt((playerPos.x - targetPos.x) ** 2 + (playerPos.z - targetPos.z) ** 2);
                document.getElementById('delivery-distance-value').textContent = Math.round(distance);

                // Update time
                const seconds = Math.floor(deliveryTimer);
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = seconds % 60;
                document.getElementById('delivery-timer-value').textContent = 
                    `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;

                // Update Arrow Helper
                const directionVector = new THREE.Vector3(targetPos.x - playerPos.x, 0, targetPos.z - playerPos.z).normalize();
                arrowHelper.setDirection(directionVector);
                arrowHelper.position.copy(playerPos).add(new THREE.Vector3(0, 5, 0));
            }

            document.getElementById('coin-count').textContent = coins;
        }

        function handleCollision(event) {
            const bodyA = event.bodyA;
            const bodyB = event.bodyB;
            
            // Check if player collided with a coin
            let coinBody = null;
            if (bodyA === body && bodyB.type === 'coin') {
                coinBody = bodyB;
            } else if (bodyB === body && bodyA.type === 'coin') {
                coinBody = bodyA;
            }

            if (coinBody) {
                // Collect coin
                coins += 10;
                world.removeBody(coinBody);
                scene.remove(coinBody.mesh);
                coinBody.isDead = true;
                
                // Spawn a new one
                spawnCoin();
            }
        }

        function endGame(isMissionFail) {
            isGameRunning = false;
            
            // Police mode end
            if (isPoliceModeActive) {
                bustedScreenEl.style.display = 'flex';
                // Clean up police car
                if (policeVehicle) {
                    policeVehicle.removeFromWorld(world);
                    world.removeBody(policeBody);
                    scene.remove(policeMesh);
                    policeBody.isDead = true;
                    policeWheels.forEach(wheelMesh => policeMesh.remove(wheelMesh));
                }
            } 
            
            // Delivery mode end
            if (isDeliveryModeActive) {
                // If isMissionFail is true, it means time ran out
                if (isMissionFail) {
                    document.getElementById('busted-text').textContent = "MISSION FAILED";
                } else {
                    document.getElementById('busted-text').textContent = "GAME OVER"; // For player crash or other failure
                }
                bustedScreenEl.style.display = 'flex';
                deliveryHudEl.style.display = 'none';
            }

            // Update high score
            if (coins > highScore) {
                highScore = coins;
                saveGameData();
            }
        }

        restartBtn.addEventListener('click', () => {
            bustedScreenEl.style.display = 'none';
            // Reset state
            coins = 0;
            respawnCar();
            
            // Re-enter game setup flow
            if (isPoliceModeActive) {
                // Restart police chase
                isPoliceModeActive = true;
                spawnPolice(body.position);
                policeHudEl.style.display = 'block';
            } else if (isDeliveryModeActive) {
                // Restart delivery
                isDeliveryModeActive = true;
                policeHudEl.style.display = 'none';
                spawnRandomDeliveryTarget();
            } else {
                // Reset to free roam
                isPoliceModeActive = false;
                isDeliveryModeActive = false;
                policeHudEl.style.display = 'none';
            }

            // Restore car control state
            keys.W = keys.S = keys.A = keys.D = keys.SPACE = false;
            
            isGameRunning = true;
        });

        // =========================================================================
        // GAME LIFECYCLE
        // =========================================================================

        function animate(time) {
            requestAnimationFrame(animate);

            if (!lastTime) {
                lastTime = time;
                return;
            }

            const deltaTime = (time - lastTime) / 1000;
            lastTime = time;

            if (isGameRunning) {
                // Physics Update
                world.step(1/60, deltaTime, 3);

                // Car Control
                updateCarControl();

                // Police AI Update
                if (isPoliceModeActive) {
                    updatePoliceAI(deltaTime);
                    updatePoliceVisuals();
                }

                // Delivery check
                if (isDeliveryModeActive) {
                    checkDeliveryCompletion();
                }

                // Visual Updates
                updateCarVisuals();
                updateEngineSound();
                updateHUD(deltaTime);
            }
            
            // Rendering
            renderer.render(scene, currentCamera);
        }

        // =========================================================================
        // DATA PERSISTENCE & MENU
        // =========================================================================

        function saveGameData() {
            localStorage.setItem('hyperDriveHighScore', highScore);
        }

        function loadGameData() {
            highScore = parseInt(localStorage.getItem('hyperDriveHighScore') || '0');
            document.getElementById('high-score-value').textContent = highScore;
        }

        document.getElementById('splash').addEventListener('click', () => {
            window.enterGame();
        });

        document.getElementById('mode-free').addEventListener('click', (e) => {
            e.stopPropagation();
            document.querySelectorAll('#splash-controls .control-btn').forEach(btn => btn.classList.remove('active-mode'));
            e.target.classList.add('active-mode');
            isPoliceModeActive = false;
            isDeliveryModeActive = false;
        });

        document.getElementById('mode-delivery').addEventListener('click', (e) => {
            e.stopPropagation();
            document.querySelectorAll('#splash-controls .control-btn').forEach(btn => btn.classList.remove('active-mode'));
            e.target.classList.add('active-mode');
            isPoliceModeActive = false;
            isDeliveryModeActive = true;
            coins = 0; // Reset coins for mission mode
            spawnRandomDeliveryTarget();
        });

        document.getElementById('mode-police').addEventListener('click', (e) => {
            e.stopPropagation();
            document.querySelectorAll('#splash-controls .control-btn').forEach(btn => btn.classList.remove('active-mode'));
            e.target.classList.add('active-mode');
            isPoliceModeActive = true;
            isDeliveryModeActive = false;
            coins = 0; // Reset coins for mission mode
            spawnPolice(new CANNON.Vec3(0, 0, 0)); // Initial spawn
        });


        // =========================================================================
        // MAIN ENTRY POINT
        // =========================================================================
        
        function initSystem() {
            loadGameData(); 
            setupMobileControls();
            
            initThree();
            initCannon();
            initGround();
            initCameraAndLights();
            initLoaders();
            loadCarModel();
            loadTireModel();
            loadPoliceModel(); // Load police model prototype
            loadCity();
            loadCoinPrototype();
            loadArrowModel(); 
            
            animate();
        }

        window.enterGame = function() { 
            if(!audioCtx) initAudio(); 
            document.getElementById('splash').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('splash').style.display = 'none';
                document.getElementById('hud-layer').style.display = 'flex';
            }, 500);
            
            isGameRunning = true; 
            
            // Initial Mode Setup
            if(isPoliceModeActive) {
                spawnPolice(body.position);
            } else if (isDeliveryModeActive) {
                spawnRandomDeliveryTarget();
            } else {
                // Free Roam Cleanup
                policeHudEl.style.display = 'none';
                if(policeVehicle) policeVehicle.removeFromWorld(world);
                if(deliveryTargetPosition) deliveryHudEl.style.display = 'none';
            }
        }

        window.addEventListener('resize', () => {
            if (renderer && cameraChase && cameraCockpit) {
                renderer.setSize(window.innerWidth, window.innerHeight);
                const aspect = window.innerWidth / window.innerHeight;
                cameraChase.aspect = aspect;
                cameraChase.updateProjectionMatrix();
                cameraCockpit.aspect = aspect;
                cameraCockpit.updateProjectionMatrix();
            }
        });

        document.addEventListener('DOMContentLoaded', initSystem);

    </script>
</body>
</html>
